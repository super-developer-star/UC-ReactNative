/**
 * UCMidtier
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

declare var fetch: any;
const isomorphicFetch = fetch;
const assign = Object.assign;

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "https://www.undergroundcellar.com".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface AccessLogModel {
    "acType"?: string;
    "acUrl"?: string;
    "acIpv6"?: string;
    "acOffersef"?: string;
    "acQsEmail"?: string;
    "acQsFname"?: string;
    "acQsLname"?: string;
    "acReferrer"?: string;
    "acSessionid"?: string;
}

export interface AchievementModel {
    "name"?: string;
    "description"?: string;
    "totalPoints"?: number;
    "records"?: Array<AchievementRecord>;
}

export interface AchievementRecord {
    "itemId"?: string;
    "name"?: string;
    "date"?: Date;
    "pointsEarned"?: number;
}

export interface AddressModelResponse {
    "apiStatus"?: string;
    "id"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "address1"?: string;
    "address2"?: string;
    "city"?: string;
    "isDefault"?: boolean;
    "cplId"?: string;
    "state"?: string;
    "carrierPreference"?: string;
    "zip"?: string;
    "phone"?: string;
    "status"?: number;
    "dateAdded"?: Date;
}

export interface AdminOfferOverviewItem {
    "status"?: string;
    "dueDate"?: Date;
}

export interface AdminOfferOverviewModel {
    "offerStartDate"?: Date;
    "items"?: { [key: string]: AdminOfferOverviewItem; };
}

export interface AdminReferralModel {
    "userEmail"?: string;
    "referredUserEmail"?: string;
}

export interface AdminSkuDelivery {
    "items"?: string;
    "arrivalId"?: string;
    "offerId"?: string;
    "eta"?: Date;
    "invoiceLink"?: string;
    "comments"?: string;
    "deliveryCost"?: number;
    "isReceived"?: boolean;
    "receivedDate"?: Date;
    "enteredDate"?: Date;
}

export interface AdminUserPushModel {
    "userQuery"?: string;
    "searchResult"?: Array<UserModelExtended>;
    "body"?: string;
    "deepLink"?: string;
    "title"?: string;
}

export interface ApiBillingModelWithAuthnet {
    "userGuid"?: string;
    "authNetUserProfileId"?: string;
    "authNetUserId"?: string;
    "authNetPaymentProfileId"?: string;
    "authNetShippingProfileId"?: string;
    "isDeleted"?: boolean;
    "billingAddressId"?: string;
    "cvv": string;
    "firstName": string;
    "lastName": string;
    "dateAdded"?: Date;
    "expiryYear"?: number;
    "expiryMonth"?: number;
    "cardNumber"?: string;
    "id"?: string;
    "isDefault"?: boolean;
    "cardType"?: string;
}

export interface ApiBillingModelWithCardNumber {
    "billingAddressId"?: string;
    "cvv": string;
    "firstName": string;
    "lastName": string;
    "dateAdded"?: Date;
    "expiryYear"?: number;
    "expiryMonth"?: number;
    "cardNumber"?: string;
    "id"?: string;
    "isDefault"?: boolean;
    "cardType"?: string;
}

export interface ApiResultBoolean {
    "value"?: boolean;
    "success"?: boolean;
    "message"?: string;
}

export interface ApiResultNhUserEmailPreference {
    "value"?: NhUserEmailPreference;
    "success"?: boolean;
    "message"?: string;
}

export interface ApiResultOfferCheckoutModel {
    "value"?: OfferCheckoutModel;
    "success"?: boolean;
    "message"?: string;
}

export interface ApiResultPasswordChangeModel {
    "value"?: PasswordChangeModel;
    "success"?: boolean;
    "message"?: string;
}

export interface ApiResultString {
    "value"?: string;
    "success"?: boolean;
    "message"?: string;
}

export interface ApiResultUserAuthResultModel {
    "value"?: UserAuthResultModel;
    "success"?: boolean;
    "message"?: string;
}

export interface ApplePushEnroll {
    "deviceToken"?: string;
    "entryPoint"?: string;
}

export interface Audio {
    "duration"?: number;
    "performer"?: string;
    "title"?: string;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface CallbackQuery {
    "id"?: string;
    "from"?: User;
    "message"?: Message;
    "inlineMessageId"?: string;
    "data"?: string;
}

export interface CampaignApiModel {
    "title"?: string;
    "landingHtml"?: string;
    "shareTitle"?: string;
    "shareDescription"?: string;
    "endDate"?: Date;
    "prize"?: Array<PrizeModel>;
    "additionalDetails"?: string;
    "type"?: CampaignApiModelTypeEnum;
    "landingPages"?: Array<any>;
    "userEntries"?: number;
    "invitedByUser"?: number;
    "totalEntries"?: number;
    "userInCampaign"?: boolean;
    "isActive"?: boolean;
}

export type CampaignApiModelTypeEnum = "0" | "1";
export interface CampaignEntryModel {
    "userId"?: number;
    "campaignId"?: number;
    "invitedByUserId"?: number;
}

export interface CampaignExportModel {
    "bonus"?: number;
    "email"?: string;
    "referrals"?: number;
    "totalEntry"?: number;
    "userId"?: number;
}

export interface Chat {
    "id"?: number;
    "type"?: ChatTypeEnum;
    "title"?: string;
    "username"?: string;
    "firstName"?: string;
    "lastName"?: string;
}

export type ChatTypeEnum = "0" | "1" | "2" | "3";
export interface CheckoutPromoCodeModel {
    "code"?: string;
    "error"?: CheckoutPromoCodeModelErrorEnum;
    "discountApplied"?: number;
}

export type CheckoutPromoCodeModelErrorEnum = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7";
export interface ChosenInlineResult {
    "resultId"?: string;
    "from"?: User;
    "location"?: Location;
    "inlineMessageId"?: string;
    "query"?: string;
}

export interface CloudCellarV2 {
    "favoriteRegion"?: string;
    "favoriteVarietal"?: string;
    "userName"?: string;
    "lifetimeValueSpent"?: number;
    "lifetimeUpgradeReceived"?: number;
    "shippingSavings"?: number;
    "shipments"?: any;
    "allItems"?: Array<CloudCellarV2Group>;
    "userImg"?: string;
    "signupDate"?: Date;
}

export interface CloudCellarV2Group {
    "item"?: PgCloudCellarRecord;
    "paid"?: Array<number>;
    "qtyAvailable"?: number;
    "qtyShipped"?: number;
    "qtyEnRoute"?: number;
    "qtyManual"?: number;
}

export interface CloudCheckoutItem {
    "sku"?: string;
    "qty"?: number;
}

export interface CloudCheckoutModel {
    "shippingMethod"?: CloudCheckoutModelShippingMethodEnum;
    "icePack"?: boolean;
    "giftMessage"?: string;
    "bottles"?: Array<CloudCheckoutItem>;
    "additionalItems"?: Array<CloudCheckoutItem>;
    "protectShipment"?: boolean;
    "protectShipmentValue"?: number;
    "protectShipmentPercent"?: number;
    "userGuid": string;
    "creditCardId": string;
    "shippingAddressId": string;
    "promoCode": Array<CheckoutPromoCodeModel>;
    "appId"?: string;
    "useAccountCredit"?: boolean;
    "result"?: ShipOrderResult;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "noAuthAddress"?: NhAddressModel;
    "validationWarnings"?: Array<ValidationResult>;
    "validationErrors"?: Array<ValidationResult>;
}

export type CloudCheckoutModelShippingMethodEnum = "0" | "1" | "2";
export interface CodeWithOrder {
    "code"?: NhPromoCodeModel;
    "usedWithOrders"?: Array<NhOrderModel>;
    "isReferral"?: boolean;
    "isRedeemed"?: boolean;
}

export interface Cohort {
    "firstPurchase"?: string;
    "cohortSize"?: number;
    "totalQty"?: number;
    "totalOrders"?: number;
    "totalRev"?: number;
    "userLifetimeMth"?: string;
}

export interface Contact {
    "phoneNumber"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "userId"?: number;
}

export interface DeficitItem {
    "sku"?: string;
    "lastOrder"?: Date;
    "firstOrder"?: Date;
    "qtyOwedOverTimeLimit"?: number;
    "qtyInStock"?: number;
    "retailPrice"?: number;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface Document {
    "thumb"?: PhotoSize;
    "fileName"?: string;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface EmailCapture {
    "email"?: string;
    "favoriteVarietal"?: string;
}

export interface GroupItemEntity {
    "groupItemId"?: string;
    "referenceIdentity"?: string;
    "groupName"?: string;
    "groupType"?: GroupItemEntityGroupTypeEnum;
    "dateAdded"?: Date;
}

export type GroupItemEntityGroupTypeEnum = "1" | "2" | "3";
export interface InlineQuery {
    "id"?: string;
    "from"?: User;
    "query"?: string;
    "location"?: Location;
    "offset"?: string;
}

export interface InviteByEmailModel {
    "userUrlProfile"?: string;
    "newUserEmail"?: string;
    "newUserName"?: string;
}

export interface ItemDetailEntity {
    "itemDetailGuid"?: string;
    "region"?: string;
    "appel"?: string;
    "varietal"?: string;
    "vintage"?: number;
    "offerWineSizeId"?: number;
    "abv"?: number;
    "wineTastingNotes"?: string;
    "winemakerNotes"?: string;
    "retailPrice"?: number;
    "wineryGuid"?: string;
    "urlKey"?: string;
    "brand"?: string;
    "countryCode"?: string;
    "upc"?: string;
    "isWine"?: boolean;
    "isBeer"?: boolean;
    "isLiquor"?: boolean;
    "isSparkling"?: boolean;
    "isLargeFormat"?: boolean;
    "isIntl"?: boolean;
    "isSmallProduction"?: boolean;
    "isOversize"?: boolean;
    "ctWineId"?: number;
    "ctProducerId"?: number;
    "ctLikes"?: number;
    "ctTastingNotes"?: number;
    "ctReview"?: number;
    "ctCommunityScore"?: number;
    "ctQty"?: number;
    "wineType"?: string;
    "wineProducer"?: string;
    "wineDesignation"?: string;
    "wineVineyard"?: string;
    "wineCountry"?: string;
    "wineSubregion"?: string;
    "wineWebUrl"?: string;
    "wineDrinkStart"?: number;
    "wineDrinkEnd"?: number;
    "redirectTo"?: string;
    "wineProducerUuid"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface ItemDetailList {
    "itemCount"?: number;
    "items"?: Array<ItemDetailEntity>;
    "varietals"?: Array<TupleStringInt32>;
    "regions"?: Array<TupleStringInt32>;
    "countries"?: Array<TupleStringInt32>;
    "subregions"?: Array<TupleStringInt32>;
    "appellations"?: Array<TupleStringInt32>;
    "types"?: Array<TupleStringInt32>;
    "producers"?: Array<TupleStringInt32>;
}

export interface KpiItem {
    "date"?: Date;
    "newUsers"?: number;
    "totalUsers"?: number;
    "newCustomers"?: number;
    "totalCustomers"?: number;
    "newOrders"?: number;
    "totalOrders"?: number;
    "newBottles"?: number;
    "totalBottles"?: number;
    "newSalesRevenue"?: number;
    "totalSalesRevenue"?: number;
    "directShippingRevenue"?: number;
    "cloudShippingRevenue"?: number;
    "totalShippingRevenue"?: number;
    "orderTaxRevenue"?: number;
    "creditsUsed"?: number;
    "promoCodeValueUsed"?: number;
}

export interface LeaderboardItem {
    "userId"?: string;
    "userDisplayName"?: string;
    "userSef"?: string;
    "points"?: number;
}

export interface LeaderboardItemGroup {
    "participants"?: Array<LeaderboardItem>;
    "groupName"?: string;
}

export interface LeaderboardModel {
    "contestBegin"?: Date;
    "contestEnd"?: Date;
    "items"?: Array<LeaderboardItemGroup>;
}

export interface LiveFeedItem {
    "quantity"?: number;
    "name"?: string;
    "url"?: string;
    "imageUrl"?: string;
}

export interface Location {
    "longitude"?: number;
    "latitude"?: number;
}

export interface ManifestSwapAction {
    "action"?: string;
    "manifestId"?: string;
    "email"?: string;
    "skuEntity"?: SkuEntity;
    "retailPrice"?: number;
    "taxableValue"?: number;
    "estimatedTaxAllocated"?: number;
    "shippingCaseGuid"?: string;
    "isSuspended"?: boolean;
    "itemGroupId"?: string;
    "pickIndex"?: number;
    "replacementForManifestGuid"?: string;
    "creditedForGuid"?: string;
}

export interface Message {
    "messageId"?: number;
    "from"?: User;
    "date"?: Date;
    "chat"?: Chat;
    "forwardFrom"?: User;
    "forwardFromChat"?: Chat;
    "forwardDate"?: Date;
    "replyToMessage"?: Message;
    "editDate"?: Date;
    "text"?: string;
    "entities"?: Array<MessageEntity>;
    "audio"?: Audio;
    "document"?: Document;
    "photo"?: Array<PhotoSize>;
    "sticker"?: Sticker;
    "video"?: Video;
    "voice"?: Voice;
    "caption"?: string;
    "contact"?: Contact;
    "location"?: Location;
    "venue"?: Venue;
    "newChatMember"?: User;
    "leftChatMember"?: User;
    "newChatTitle"?: string;
    "newChatPhoto"?: Array<PhotoSize>;
    "deleteChatPhoto"?: boolean;
    "groupChatCreated"?: boolean;
    "supergroupChatCreated"?: boolean;
    "channelChatCreated"?: boolean;
    "migrateToChatId"?: number;
    "migrateFromChatId"?: number;
    "pinnedMessage"?: Message;
}

export interface MessageEntity {
    "type"?: MessageEntityTypeEnum;
    "offset"?: number;
    "length"?: number;
    "url"?: string;
    "user"?: User;
}

export type MessageEntityTypeEnum = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" | "10";
export interface NhAddressModel {
    "id"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "address1"?: string;
    "address2"?: string;
    "city"?: string;
    "isDefault"?: boolean;
    "cplId"?: string;
    "state"?: string;
    "carrierPreference"?: string;
    "zip"?: string;
    "phone"?: string;
    "status"?: number;
    "dateAdded"?: Date;
}

export interface NhAdjustment {
    "userId"?: string;
    "adjustmentId"?: string;
    "items"?: Array<NhAdjustmentItem>;
    "adjutmentCreateTime"?: Date;
    "adjustmentExecTime"?: Date;
}

export interface NhAdjustmentItem {
    "adjustmentItemId"?: string;
    "add"?: boolean;
    "sku"?: string;
    "manifestUpdated"?: OfferV2ManifestEntity;
    "manifestCreated"?: OfferV2ManifestEntity;
    "legacyManifestUpdated"?: string;
    "legacyManifestCreated"?: string;
}

export interface NhCreditModel {
    "creditId"?: string;
    "date"?: Date;
    "originalAmt"?: number;
    "creditAmt"?: number;
    "expiry"?: Date;
    "usedWithOrders"?: string;
    "comment"?: string;
    "creditForReferredUser"?: string;
    "creditOldId"?: number;
    "dateUsed"?: Date;
    "isSuspended"?: boolean;
    "isExpired"?: boolean;
}

export interface NhItemGroupEntity {
    "parentOffer"?: OfferV2Entity;
    "qtyInsideGroup"?: number;
    "estRemaining"?: number;
    "itemList"?: Array<OfferV2ItemEntity>;
    "retailPrice"?: number;
    "estChance"?: number;
    "itemGroupGuid"?: string;
    "pickQty"?: number;
    "pickRoundRobin"?: boolean;
    "qtyOfGroup"?: number;
    "urlKey"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface NhItemGroupViewEntity {
    "itemDetailGuid"?: string;
    "sku"?: string;
    "isSuspended"?: boolean;
    "qtyOfGroup"?: number;
    "pickRoundRobin"?: boolean;
    "qtyInsideGroup"?: number;
    "estRemaining"?: number;
    "estChance"?: number;
    "retailPrice"?: number;
    "itemGroupGuid"?: string;
    "pickQty"?: number;
    "urlKey"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface NhOrderModel {
    "cohortSignup"?: Date;
    "cohortUserMonth"?: number;
    "revealDate"?: Date;
    "isRevealed"?: boolean;
    "xUserEmail"?: string;
    "billing"?: ApiBillingModelWithAuthnet;
    "skuList"?: string;
    "bottleList"?: string;
    "paymentAuthCode"?: string;
    "paymentAuthDate"?: Date;
    "transactionId"?: string;
    "promoCode"?: string;
    "bottles"?: Array<NhItemGroupViewEntity>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "orderGuid"?: string;
    "totalQuantity"?: number;
    "totalPrice"?: number;
    "discount"?: number;
    "creditDiscount"?: number;
    "tax"?: number;
    "timestamp"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerId"?: string;
    "offerTitle"?: string;
    "offerSef"?: string;
    "userNthOrder"?: number;
    "unitPrice"?: number;
}

export interface NhPromoCodeModel {
    "promoCode"?: string;
    "isPercent"?: boolean;
    "promoAmount"?: number;
    "minBottlesQty"?: number;
    "minSubtotal"?: number;
    "date"?: Date;
    "startDate"?: Date;
    "expiry"?: Date;
    "promoEnabled"?: boolean;
    "redemptionsAllowedPerUser"?: number;
    "redemptionsAllowedOverall"?: number;
    "promoGroupName"?: string;
    "firstOrderOnly"?: boolean;
    "leftOverCredit"?: boolean;
    "amtPaid"?: number;
    "createdFromManifest"?: string;
    "issuedToUser"?: string;
    "isRefundable"?: boolean;
    "isExpired"?: boolean;
}

export interface NhSellerEntity {
    "sellerGuid"?: string;
    "sellerName"?: string;
    "sellerUrlKey"?: string;
    "sellerImageUrl"?: string;
    "sellerBlurb"?: string;
    "isWinery"?: boolean;
    "isRetail"?: boolean;
}

export interface NhSkuDelivery {
    "items"?: Array<NhSkuDeliveryItem>;
    "arrivalId"?: string;
    "offerId"?: string;
    "eta"?: Date;
    "invoiceLink"?: string;
    "comments"?: string;
    "deliveryCost"?: number;
    "isReceived"?: boolean;
    "receivedDate"?: Date;
    "enteredDate"?: Date;
}

export interface NhSkuDeliveryItem {
    "arrivalItemId"?: string;
    "arrivalItemSku"?: string;
    "unitCost"?: number;
    "arrivalQtyExpected"?: number;
    "arrivalQtyActual"?: number;
}

export interface NhUserEmailPreference {
    "preferenceId"?: string;
    "email"?: string;
    "sendAbandonedCheckoutEmail"?: boolean;
    "sendOrderConfirmation"?: boolean;
    "sendOrderCancellation"?: boolean;
    "sendReferralNotice"?: boolean;
    "sendCloudcellarReminder"?: boolean;
    "sendCreditReminder"?: boolean;
    "sendSystemNotice"?: boolean;
    "emailedInvited10"?: Date;
    "emailedCredits"?: Date;
    "emailedHeavyBuyer"?: Date;
    "emailedStagnant"?: Date;
    "emailedAbandonedCheckout"?: Date;
    "emailedCreditReminder"?: Date;
    "emailedCloudcellarReminder"?: Date;
    "unsubCampaignTitle"?: string;
    "unsubCampaignId"?: string;
    "unsubReason"?: string;
    "unsubTime"?: Date;
    "verifyStatus"?: string;
    "verifyDetail"?: string;
}

export interface NhUserModel {
    "acquisitionCost"?: number;
    "cacheAchievementPoints"?: number;
    "dotmailerId"?: number;
    "userName"?: string;
    "userId"?: number;
    "userGuid"?: string;
    "lastOrder"?: Date;
    "profileImageUrl"?: string;
    "isPrivate"?: boolean;
    "referredByUserId"?: string;
    "defaultAddressId"?: string;
    "defaultPaymentId"?: string;
    "signupDate"?: Date;
    "lastLoginDate"?: Date;
    "lastPurchaseDate"?: Date;
    "firstPurchaseDate"?: Date;
    "sessionId"?: string;
    "password"?: string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "email"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface NhWordGamePrize {
    "prize"?: string;
    "sku"?: string;
    "numRemaining"?: number;
    "canClaim"?: boolean;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export interface OfferCheckoutModel {
    "offerGuid"?: string;
    "offerSef"?: string;
    "bottlesQty"?: number;
    "wineIds"?: Array<string>;
    "revealDate"?: Date;
    "userGuid": string;
    "creditCardId": string;
    "shippingAddressId": string;
    "promoCode": Array<CheckoutPromoCodeModel>;
    "appId"?: string;
    "useAccountCredit"?: boolean;
    "result"?: UpgradeOrderResult;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "noAuthAddress"?: NhAddressModel;
    "validationWarnings"?: Array<ValidationResult>;
    "validationErrors"?: Array<ValidationResult>;
}

export interface OfferDetailModel {
    "url"?: string;
    "title"?: string;
    "subtitle"?: string;
    "offerImgCsv"?: string;
    "offerImg"?: Array<string>;
    "minPrice"?: number;
    "maxPrice"?: number;
    "offerItemName"?: string;
    "offerItemNamePlural"?: string;
    "minQtyAllow"?: number;
    "maxQtyAllow"?: number;
    "pricePerBottle"?: number;
    "bottlesRemaining"?: number;
    "offerTotal"?: number;
    "offerStatus"?: number;
    "offerGuid"?: string;
    "sellerGuid"?: string;
    "buyText"?: string;
    "states"?: Array<string>;
    "expiryDate"?: Date;
    "startDate"?: Date;
    "isFeatured"?: boolean;
    "isDirectShip"?: boolean;
    "wineryName"?: string;
    "wineryNotes"?: string;
    "wineryAbout"?: string;
    "metaDescription"?: string;
    "metaKeywords"?: string;
    "metaTitle"?: string;
    "numberOfUpgradesGuaranteed"?: Array<number>;
    "wineryImages"?: Array<string>;
}

export interface OfferV2AdminManifest {
    "manifestId"?: string;
    "name"?: string;
    "price"?: number;
    "sku"?: string;
    "isSuspended"?: boolean;
    "winnerGuid"?: string;
    "xWinnerEmail"?: string;
    "qtyInStock"?: number;
    "shippingCaseGuid"?: string;
    "paymentStatus"?: string;
    "orderStatus"?: string;
}

export interface OfferV2Entity {
    "offerContent"?: string;
    "shippingAvailability"?: string;
    "dateCreated"?: Date;
    "isApproved"?: boolean;
    "isSideDeal"?: boolean;
    "priority"?: number;
    "enableAutoBuy"?: boolean;
    "enablePromo"?: boolean;
    "enableCredit"?: boolean;
    "enableSpinAgain"?: boolean;
    "enableTax"?: boolean;
    "adminNotes"?: string;
    "capturedDate"?: Date;
    "winery"?: WineryModel;
    "itemGroupsFlat"?: Array<NhItemGroupViewEntity>;
    "url"?: string;
    "title"?: string;
    "subtitle"?: string;
    "offerImgCsv"?: string;
    "offerImg"?: Array<string>;
    "minPrice"?: number;
    "maxPrice"?: number;
    "offerItemName"?: string;
    "offerItemNamePlural"?: string;
    "minQtyAllow"?: number;
    "maxQtyAllow"?: number;
    "pricePerBottle"?: number;
    "bottlesRemaining"?: number;
    "offerTotal"?: number;
    "offerStatus"?: number;
    "offerGuid"?: string;
    "sellerGuid"?: string;
    "buyText"?: string;
    "states"?: Array<string>;
    "expiryDate"?: Date;
    "startDate"?: Date;
    "isFeatured"?: boolean;
    "isDirectShip"?: boolean;
    "wineryName"?: string;
    "wineryNotes"?: string;
    "wineryAbout"?: string;
    "metaDescription"?: string;
    "metaKeywords"?: string;
    "metaTitle"?: string;
    "numberOfUpgradesGuaranteed"?: Array<number>;
    "wineryImages"?: Array<string>;
}

export interface OfferV2ItemEntity {
    "itemId"?: string;
    "parentItemGroup"?: NhItemGroupEntity;
    "sku"?: SkuEntity;
    "qty"?: number;
}

export interface OfferV2ManifestEntity {
    "manifestId"?: string;
    "skuEntity"?: SkuEntity;
    "retailPrice"?: number;
    "taxableValue"?: number;
    "estimatedTaxAllocated"?: number;
    "shippingCaseGuid"?: string;
    "isSuspended"?: boolean;
    "itemGroupId"?: string;
    "pickIndex"?: number;
    "replacementForManifestGuid"?: string;
    "creditedForGuid"?: string;
}

export interface OrderGeniusState {
    "cancelBy"?: Date;
    "orderEntity"?: Array<NhOrderModel>;
}

export interface OrderModel {
    "bottles"?: Array<NhItemGroupViewEntity>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "orderGuid"?: string;
    "totalQuantity"?: number;
    "totalPrice"?: number;
    "discount"?: number;
    "creditDiscount"?: number;
    "tax"?: number;
    "timestamp"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerId"?: string;
    "offerTitle"?: string;
    "offerSef"?: string;
    "userNthOrder"?: number;
    "unitPrice"?: number;
}

export interface OrderModelExtended {
    "billing"?: ApiBillingModelWithAuthnet;
    "skuList"?: string;
    "bottleList"?: string;
    "paymentAuthCode"?: string;
    "paymentAuthDate"?: Date;
    "transactionId"?: string;
    "promoCode"?: string;
    "bottles"?: Array<NhItemGroupViewEntity>;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "orderGuid"?: string;
    "totalQuantity"?: number;
    "totalPrice"?: number;
    "discount"?: number;
    "creditDiscount"?: number;
    "tax"?: number;
    "timestamp"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerId"?: string;
    "offerTitle"?: string;
    "offerSef"?: string;
    "userNthOrder"?: number;
    "unitPrice"?: number;
}

export interface OrderViewModel {
    "orderId"?: string;
    "offerSef"?: string;
    "offerTitle"?: string;
    "date"?: Date;
    "credit"?: number;
    "discount"?: number;
    "subtotal"?: number;
    "tax"?: number;
    "amtCharged"?: number;
    "status"?: string;
    "paymentStatus"?: string;
    "unitPrice"?: number;
    "isRevealed"?: boolean;
    "lineItems"?: Array<NhItemGroupViewEntity>;
    "address"?: NhAddressModel;
}

export interface OrdersOverviewModel {
    "orders"?: Array<OrderViewModel>;
    "shipments"?: Array<OrderViewModel>;
}

export interface OverallPlan {
    "canFree"?: Array<SkuPlan>;
    "userPlan"?: { [key: string]: number; };
    "inactiveUserPlan"?: { [key: string]: number; };
}

export interface PasswordChangeModel {
    "oldPassword": string;
    "newPassword": string;
    "confirmNewPassword": string;
}

export interface PasswordResetModel {
    "email": string;
    "resetToken"?: string;
    "newPassword"?: string;
}

export interface PaymentWithAddressModel {
    "payment"?: ApiBillingModelWithAuthnet;
    "address"?: NhAddressModel;
}

export interface PgCloudCellarRecord {
    "isCounted"?: boolean;
    "varietal"?: string;
    "region"?: string;
    "appel"?: string;
    "states"?: Array<string>;
    "sku"?: string;
    "urlKey"?: string;
    "retailPrice"?: number;
    "qtyInStock"?: number;
    "isManual"?: boolean;
    "eta"?: Date;
    "isClearance"?: boolean;
    "isSuspended"?: boolean;
    "shipIncentive"?: number;
    "manifestGuid"?: string;
    "taxValue"?: number;
    "taxAllocated"?: number;
    "orderGuid"?: string;
    "winnerGuid"?: string;
    "orderDate"?: Date;
    "orderStatus"?: string;
    "paymentStatus"?: string;
    "offerGuid"?: string;
    "offerSef"?: string;
    "wineDrinkEnd"?: Date;
    "isAutographed"?: boolean;
    "isWine"?: boolean;
    "isBeer"?: boolean;
    "isLargeFormat"?: boolean;
    "shipCase"?: string;
    "shipMethod"?: PgCloudCellarRecordShipMethodEnum;
    "shipPrice"?: number;
    "tracking"?: string;
    "shipDate"?: Date;
    "itemGroupId"?: string;
    "displayDesc"?: string;
    "bottleImgCsv"?: string;
    "labelImgCsv"?: string;
    "displayName"?: string;
    "bottleImg"?: Array<string>;
    "labelImg"?: Array<string>;
}

export type PgCloudCellarRecordShipMethodEnum = "0" | "1" | "2" | "3" | "4" | "5" | "10" | "11" | "12" | "13" | "15" | "18" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "30" | "31" | "32" | "33" | "35" | "36" | "37" | "38" | "100" | "111" | "140" | "165" | "172" | "188" | "7000" | "7001" | "7002" | "7003" | "7005" | "7010" | "7011" | "7012" | "7013" | "7020" | "7021" | "7022" | "7023" | "7024" | "7025" | "7026" | "7027" | "7030" | "7031" | "7032" | "7033" | "7035" | "7037";
export interface PhotoSize {
    "width"?: number;
    "height"?: number;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface PrizeModel {
    "title"?: string;
    "image"?: string;
    "details"?: string;
}

export interface PurchaseOrder {
    "id"?: string;
    "purchaseOrderDetailList"?: Array<PurchaseOrderDetail>;
}

export interface PurchaseOrderDetail {
    "cost"?: number;
    "costSpecified"?: boolean;
    "dueDate"?: string;
    "id"?: number;
    "idSpecified"?: boolean;
    "itemId"?: string;
    "orderDate"?: string;
    "orderQuantity"?: number;
    "orderQuantitySpecified"?: boolean;
    "per"?: number;
    "perSpecified"?: boolean;
    "receivedDate"?: string;
    "receivedQuantity"?: number;
    "receivedQuantitySpecified"?: boolean;
    "vendorId"?: number;
    "vendorIdSpecified"?: boolean;
}

export interface PurchaseOrderItem {
    "sku"?: string;
    "cogs"?: number;
    "orderQty"?: number;
}

export interface PurchaseOrderModel {
    "items"?: Array<PurchaseOrderItem>;
    "deliveryDate"?: Date;
    "deliveryCost"?: number;
    "cplId"?: string;
    "offerGuid"?: string;
}

export interface Q1 {
    "coffeeBlack"?: boolean;
    "coffeeCream"?: boolean;
    "coffeeCreamSugar"?: boolean;
    "coffeeFrappuccino"?: boolean;
}

export interface Q2 {
    "saltyPopcorn"?: boolean;
    "charcuterie"?: boolean;
    "applesAndPeanutButter"?: boolean;
    "fruitSmoothie"?: boolean;
}

export interface Q3 {
    "teriyaki"?: boolean;
    "mushroom"?: boolean;
    "risotto"?: boolean;
    "pastaWithArugula"?: boolean;
}

export interface Q4 {
    "lemonSorbet"?: boolean;
    "caramelIceCream"?: boolean;
    "darkChocolateMousse"?: boolean;
    "olives"?: boolean;
}

export interface Q5 {
    "level"?: string;
}

export interface Q6 {
    "redWhitePosition"?: number;
}

export interface Q7 {
    "redMin"?: string;
    "redMax"?: string;
    "whiteMin"?: string;
    "whiteMax"?: string;
}

export interface Q8 {
    "bottlesPerWeek"?: number;
}

export interface SessionEventModel {
    "eventMd5"?: string;
    "eventString"?: string;
}

export interface SessionModel {
    "sessionId"?: string;
    "sessionExpiration"?: Date;
    "sessionLastPage"?: string;
    "sessionFbrLhState"?: string;
    "sessionUserId"?: number;
    "sessionUserGuid"?: string;
    "sessionUserName"?: string;
    "sessionUserFname"?: string;
    "sessionUserImageurl"?: string;
    "sessionUserBalance"?: number;
    "sessionUserUrlProfile"?: string;
    "sessionUserReferralCloudName"?: string;
    "sessionLastQty"?: number;
    "sessionEmail"?: string;
    "sessionUserAgent"?: string;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
}

export interface SessionTrackModel {
    "sessionTrackId"?: string;
    "trackEvent"?: SessionEventModel;
    "trackDt"?: Date;
    "trackExtra"?: string;
}

export interface ShipOrderResult {
    "cplId"?: string;
    "shippingCaseGuid"?: string;
    "bottles"?: Array<OfferV2ManifestEntity>;
    "totalTax"?: number;
    "taxAlreadyPaid"?: number;
    "taxChargedOrRefunded"?: number;
    "protectShipmentValue"?: number;
    "shipMethods"?: Array<ShippingMethodModel>;
    "iceAvailable"?: boolean;
    "promotionsUsed"?: Array<CheckoutPromoCodeModel>;
    "promoValue"?: number;
    "accountBalanceUsed"?: number;
    "accountBalanceAvailable"?: number;
    "taxComputed"?: TaxInfo;
    "totalPrice"?: number;
    "subtotal"?: number;
}

export interface ShippingMethodModel {
    "name"?: string;
    "description"?: string;
    "price"?: number;
    "guaranteedBy"?: Date;
    "value"?: ShippingMethodModelValueEnum;
}

export type ShippingMethodModelValueEnum = "0" | "1" | "2";
export interface ShippingModel {
    "address"?: NhAddressModel;
    "shippingPrice"?: number;
    "tax"?: number;
    "iceGelPackPrice"?: number;
    "cplOrderId"?: string;
    "shippingCaseGuid"?: string;
    "shippingMethod"?: ShippingModelShippingMethodEnum;
    "shippingStatus"?: number;
    "trackingNumber"?: string;
    "date"?: Date;
    "dateProcessed"?: Date;
    "dateDelivered"?: Date;
    "shippedManifests"?: Array<OfferV2ManifestEntity>;
    "payment"?: ApiBillingModelWithAuthnet;
    "giftMessage"?: string;
    "qty"?: number;
    "transactionId"?: string;
    "cohortSignup"?: Date;
    "cohortUserMonth"?: number;
}

export type ShippingModelShippingMethodEnum = "0" | "1" | "2" | "3" | "4" | "5" | "10" | "11" | "12" | "13" | "15" | "18" | "20" | "21" | "22" | "23" | "24" | "25" | "26" | "27" | "28" | "30" | "31" | "32" | "33" | "35" | "36" | "37" | "38" | "100" | "111" | "140" | "165" | "172" | "188" | "7000" | "7001" | "7002" | "7003" | "7005" | "7010" | "7011" | "7012" | "7013" | "7020" | "7021" | "7022" | "7023" | "7024" | "7025" | "7026" | "7027" | "7030" | "7031" | "7032" | "7033" | "7035" | "7037";
export interface SkuEntity {
    "itemDetail"?: ItemDetailEntity;
    "sku"?: string;
    "suggestedPrice"?: number;
    "sellerId"?: string;
    "isAutographed"?: boolean;
    "isDeprecated"?: boolean;
    "isTaxable"?: boolean;
    "isCountedInShipment"?: boolean;
    "isPalletProgram"?: boolean;
    "drinkByDate"?: Date;
    "cacheLatestOrderDate"?: Date;
    "cacheLastRestocked"?: Date;
    "cacheLastUpdated"?: Date;
    "cacheNextDelivery"?: Date;
    "cacheNumAvailable"?: number;
    "scrambleLetters"?: string;
    "scrambleQtyAllowed"?: number;
    "allowedStatesCsv"?: string;
    "comment"?: string;
    "cogsUnit"?: number;
    "allowedStates"?: Array<string>;
}

export interface SkuPlan {
    "sku"?: string;
    "usersNeeded"?: Array<UserPlan>;
}

export interface SkuSale {
    "sku"?: string;
    "price"?: number;
    "name"?: string;
    "varietal"?: string;
    "qtyInOffer"?: number;
    "qtySold"?: number;
    "qtyInStock"?: number;
}

export interface SkuSaleItemModel {
    "offerId"?: number;
    "qtySold"?: number;
    "retailPrice"?: number;
    "wineId"?: number;
    "wineName"?: string;
    "wineSku"?: string;
}

export interface SkuSwapModel {
    "eligibleSkuSwapFrom"?: Array<string>;
    "eligibleSkuSwapTo"?: Array<string>;
    "selectedSkuSwapFrom"?: string;
    "selectedSkuSwapTo"?: Array<string>;
    "eligibleOfferSefToSwapIn"?: Array<string>;
    "selectedOfferSefToSwap"?: string;
    "credit"?: boolean;
    "creditFullValue"?: boolean;
    "qtyToSwap"?: number;
    "swapReason"?: string;
    "sendEmail"?: boolean;
    "manifestsAffected"?: Array<ManifestSwapAction>;
}

export interface SkuViewEntity {
    "cacheNumOwed"?: number;
    "cacheNumShipped"?: number;
    "cacheFriendlyName"?: string;
    "cacheSurplus"?: number;
    "varietal"?: string;
    "region"?: string;
    "itemDetailGuid"?: string;
    "sku"?: string;
    "suggestedPrice"?: number;
    "sellerId"?: string;
    "isAutographed"?: boolean;
    "isDeprecated"?: boolean;
    "isTaxable"?: boolean;
    "isCountedInShipment"?: boolean;
    "isPalletProgram"?: boolean;
    "drinkByDate"?: Date;
    "cacheLatestOrderDate"?: Date;
    "cacheLastRestocked"?: Date;
    "cacheLastUpdated"?: Date;
    "cacheNextDelivery"?: Date;
    "cacheNumAvailable"?: number;
    "scrambleLetters"?: string;
    "scrambleQtyAllowed"?: number;
    "allowedStatesCsv"?: string;
    "comment"?: string;
    "cogsUnit"?: number;
    "allowedStates"?: Array<string>;
}

export interface Sticker {
    "width"?: string;
    "height"?: string;
    "thumb"?: PhotoSize;
    "emoji"?: string;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface SupportTicket {
    "id"?: string;
    "subject"?: string;
    "description"?: string;
    "status"?: string;
    "priority"?: string;
    "requesterName"?: string;
    "requesterEmail"?: string;
    "zendeskId"?: string;
    "zendeskUrl"?: string;
    "systemResponse"?: string;
}

export interface SurplusItemDateTime {
    "key"?: Date;
    "surplusQty"?: number;
    "surplusValue"?: number;
    "deficitQty"?: number;
    "deficitValue"?: number;
    "numAvailable"?: number;
    "numOwed"?: number;
}

export interface SurplusItemString {
    "key"?: string;
    "surplusQty"?: number;
    "surplusValue"?: number;
    "deficitQty"?: number;
    "deficitValue"?: number;
    "numAvailable"?: number;
    "numOwed"?: number;
}

export interface TaxInfo {
    "taxRate"?: number;
    "regionName"?: string;
    "orderTaxAmt"?: number;
}

export interface TimeSeriesReport {
    "entityGuid"?: string;
    "begin"?: Date;
    "end"?: Date;
    "reportDate"?: Date;
    "description"?: string;
}

export interface TupleStringInt32 {
    "item1"?: string;
    "item2"?: number;
}

export interface Update {
    "updateId"?: number;
    "message"?: Message;
    "editedMessage"?: Message;
    "inlineQuery"?: InlineQuery;
    "chosenInlineResult"?: ChosenInlineResult;
    "callbackQuery"?: CallbackQuery;
}

export interface UpgradeOrderResult {
    "bottles"?: Array<NhItemGroupViewEntity>;
    "orderGuid"?: string;
    "orderUserNth"?: number;
    "promotionsUsed"?: Array<CheckoutPromoCodeModel>;
    "promoValue"?: number;
    "accountBalanceUsed"?: number;
    "accountBalanceAvailable"?: number;
    "taxComputed"?: TaxInfo;
    "totalPrice"?: number;
    "subtotal"?: number;
}

export interface User {
    "id"?: number;
    "firstName"?: string;
    "lastName"?: string;
    "username"?: string;
}

export interface UserAuthModel {
    "sessionId"?: string;
    "password"?: string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "email"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface UserAuthResultModel {
    "emailOk"?: boolean;
    "isAuthenticated"?: boolean;
    "hasEmail"?: boolean;
    "hasPassword"?: boolean;
    "hasFbToken"?: boolean;
    "session"?: SessionModel;
    "user"?: UserAuthModel;
}

export interface UserLifetimeViewRecord {
    "signupMth"?: Date;
    "latestOrder"?: Date;
    "numCustomers"?: number;
    "numUsersActive"?: number;
    "avgOrderCount"?: number;
    "totalOrderCount"?: number;
    "avgTotalOrderValuePerUser"?: number;
    "totalOrderValue"?: number;
    "sum30DayOrderValue"?: number;
    "sum30DayQty"?: number;
    "sum30DayCreditUsed"?: number;
    "sum30DaySpentWithTaxAndDiscount"?: number;
    "sum30DayDiscount"?: number;
    "sum30DayTax"?: number;
    "avg30DayOrderValue"?: number;
    "avg30DayQty"?: number;
    "avg30DayCreditUsed"?: number;
    "avg30DaySpentWithTaxAndDiscount"?: number;
    "avg30DayDiscount"?: number;
    "avg30DayTax"?: number;
    "sum60DayOrderValue"?: number;
    "sum60DayQty"?: number;
    "sum60DayCreditUsed"?: number;
    "sum60DaySpentWithTaxAndDiscount"?: number;
    "sum60DayDiscount"?: number;
    "sum60DayTax"?: number;
    "avg60DayOrderValue"?: number;
    "avg60DayQty"?: number;
    "avg60DayCreditUsed"?: number;
    "avg60DaySpentWithTaxAndDiscount"?: number;
    "avg60DayDiscount"?: number;
    "avg60DayTax"?: number;
    "sum90DayOrderValue"?: number;
    "sum90DayQty"?: number;
    "sum90DayCreditUsed"?: number;
    "sum90DaySpentWithTaxAndDiscount"?: number;
    "sum90DayDiscount"?: number;
    "sum90DayTax"?: number;
    "avg90DayOrderValue"?: number;
    "avg90DayQty"?: number;
    "avg90DayCreditUsed"?: number;
    "avg90DaySpentWithTaxAndDiscount"?: number;
    "avg90DayDiscount"?: number;
    "avg90DayTax"?: number;
    "sum365DayOrderValue"?: number;
    "sum365DayQty"?: number;
    "sum365DayCreditUsed"?: number;
    "sum365DaySpentWithTaxAndDiscount"?: number;
    "sum365DayDiscount"?: number;
    "sum365DayTax"?: number;
    "avg365DayOrderValue"?: number;
    "avg365DayQty"?: number;
    "avg365DayCreditUsed"?: number;
    "avg365DaySpentWithTaxAndDiscount"?: number;
    "avg365DayDiscount"?: number;
    "avg365DayTax"?: number;
    "groupUtmCampaign"?: string;
    "groupUtmSource"?: string;
    "groupUtmMedium"?: string;
}

export interface UserModelExtended {
    "userName"?: string;
    "userId"?: number;
    "userGuid"?: string;
    "lastOrder"?: Date;
    "profileImageUrl"?: string;
    "isPrivate"?: boolean;
    "referredByUserId"?: string;
    "defaultAddressId"?: string;
    "defaultPaymentId"?: string;
    "signupDate"?: Date;
    "lastLoginDate"?: Date;
    "lastPurchaseDate"?: Date;
    "firstPurchaseDate"?: Date;
    "sessionId"?: string;
    "password"?: string;
    "facebookAccessToken"?: string;
    "facebookUserId"?: number;
    "referralString"?: string;
    "clientIpAddress"?: string;
    "is21"?: boolean;
    "referralGroup"?: GroupItemEntity;
    "sessionUtmSource"?: string;
    "sessionUtmMedium"?: string;
    "sessionUtmCampaign"?: string;
    "referralCloudcellarName"?: string;
    "referralDomain"?: string;
    "email"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "profileUrl"?: string;
    "birthday"?: Date;
    "isTestAccount"?: boolean;
}

export interface UserPlan {
    "userEmail"?: string;
    "userGuid"?: string;
    "tryToShip"?: Array<TupleStringInt32>;
}

export interface UserReferralModel {
    "userGuid"?: string;
    "email"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "signupDate"?: Date;
    "firstOrderGuid"?: string;
    "firstOrderDate"?: Date;
    "firstOrderStatus"?: string;
    "referralCreditGuid"?: string;
}

export interface UserSummaryViewRecord {
    "userEmail"?: string;
    "userSignupDt"?: Date;
    "userLoginDt"?: Date;
    "userFirstPurchaseDate"?: Date;
    "userLastPurchaseDate"?: Date;
    "orderCount"?: number;
    "lifeOrderValue"?: number;
    "lifeQty"?: number;
    "lifeCreditUsed"?: number;
    "lifeSpentWithTaxAndDiscount"?: number;
    "lifeDiscount"?: number;
    "lifeTax"?: number;
    "x30DayOrderValue"?: number;
    "x30DayQty"?: number;
    "x30DayCreditUsed"?: number;
    "x30DaySpentWithTaxAndDiscount"?: number;
    "x30DayDiscount"?: number;
    "x30DayTax"?: number;
    "x60DayOrderValue"?: number;
    "x60DayQty"?: number;
    "x60DayCreditUsed"?: number;
    "x60DaySpentWithTaxAndDiscount"?: number;
    "x60DayDiscount"?: number;
    "x60DayTax"?: number;
    "x90DayOrderValue"?: number;
    "x90DayQty"?: number;
    "x90DayCreditUsed"?: number;
    "x90DaySpentWithTaxAndDiscount"?: number;
    "x90DayDiscount"?: number;
    "x90DayTax"?: number;
    "x365DayOrderValue"?: number;
    "x365DayQty"?: number;
    "x365DayCreditUsed"?: number;
    "x365DaySpentWithTaxAndDiscount"?: number;
    "x365DayDiscount"?: number;
    "x365DayTax"?: number;
    "userUtmCampaign"?: string;
    "userUtmSource"?: string;
    "userUtmMedium"?: string;
}

export interface ValidationResult {
    "memberNames"?: Array<string>;
    "errorMessage"?: string;
}

export interface Venue {
    "location"?: Location;
    "title"?: string;
    "address"?: string;
    "foursquareId"?: string;
}

export interface Video {
    "width"?: string;
    "height"?: string;
    "duration"?: number;
    "thumb"?: PhotoSize;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface Voice {
    "duration"?: number;
    "mimeType"?: string;
    "fileId"?: string;
    "fileSize"?: number;
    "filePath"?: string;
}

export interface WineAttributes {
    "sparkling"?: boolean;
    "largeFormat"?: boolean;
    "rare"?: boolean;
    "autographed"?: boolean;
    "highValue"?: boolean;
    "smallProduction"?: boolean;
    "cult"?: boolean;
    "international"?: boolean;
}

export interface WineGeniusData {
    "coffeeBlack"?: boolean;
    "coffeeCream"?: boolean;
    "coffeeCreamSugar"?: boolean;
    "coffeeFrappuccino"?: boolean;
    "saltyPopcorn"?: boolean;
    "charcuterie"?: boolean;
    "applesAndPeanutButter"?: boolean;
    "fruitSmoothie"?: boolean;
    "teriyaki"?: boolean;
    "mushroom"?: boolean;
    "risotto"?: boolean;
    "pastaWithArugula"?: boolean;
    "lemonSorbet"?: boolean;
    "caramelIceCream"?: boolean;
    "darkChocolateMousse"?: boolean;
    "olives"?: boolean;
    "level"?: string;
    "redWhitePosition"?: number;
    "redMin"?: string;
    "redMax"?: string;
    "whiteMin"?: string;
    "whiteMax"?: string;
    "bottlesPerWeek"?: number;
    "sparkling"?: boolean;
    "largeFormat"?: boolean;
    "rare"?: boolean;
    "autographed"?: boolean;
    "highValue"?: boolean;
    "smallProduction"?: boolean;
    "cult"?: boolean;
    "international"?: boolean;
    "overallSweet"?: number;
    "overallSour"?: number;
    "overallSalty"?: number;
    "overallBitter"?: number;
    "overallTexture"?: number;
    "firstTrait"?: string;
    "secondTrait"?: string;
    "lastTrait"?: string;
    "budget"?: number;
    "paymentGuid"?: string;
    "surveyDate"?: Date;
}

export interface WineGeniusQuestionaire {
    "q1"?: Q1;
    "q2"?: Q2;
    "q3"?: Q3;
    "q4"?: Q4;
    "q5"?: Q5;
    "q6"?: Q6;
    "q7"?: Q7;
    "q8"?: Q8;
    "q9"?: WineAttributes;
    "userPreferenceId"?: string;
    "paymentProfileGuid"?: string;
    "budget"?: number;
    "traits"?: Array<TupleStringInt32>;
}

export interface WineGeniusVacation {
    "dateSet"?: Date;
    "suspendOn"?: Date;
    "resumeOn"?: Date;
    "vacationGuid"?: string;
}

export interface WineryModel {
    "winerySef": string;
    "wineryAddress": string;
    "wineryCity": string;
    "wineryFax": string;
    "wineryZip": string;
    "wineryCountry": string;
    "wineryWebsite": string;
    "wineryOwners": string;
    "wineryWinemakers": string;
    "wineryArea": string;
    "wineryTourInfo": string;
    "wineryHours": string;
    "wineryDescription": string;
    "wineryLogo": string;
    "wineryMainImage": string;
    "wineryName": string;
    "wineryPhone": string;
    "wineryEmail": string;
    "wineryState": string;
    "visible"?: boolean;
}

export interface WordGame {
    "letters"?: Array<string>;
    "prizes"?: Array<NhWordGamePrize>;
}



/**
 * AccessLogApi - fetch parameter creator
 */
export const AccessLogApiFetchParamCreator = {
    /** 
     * @param lead 
     */
    accessLogLog(params: {  "lead": AccessLogModel; }, options?: any): FetchArgs {
        // verify required parameter "lead" is set
        if (params["lead"] == null) {
            throw new Error("Missing required parameter lead when calling accessLogLog");
        }
        const baseUrl = `/api/access/log`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lead"]) {
            fetchOptions.body = JSON.stringify(params["lead"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param lead 
     */
    accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any): FetchArgs {
        // verify required parameter "lead" is set
        if (params["lead"] == null) {
            throw new Error("Missing required parameter lead when calling accessLogPostLead");
        }
        const baseUrl = `/api/access/lead`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["lead"]) {
            fetchOptions.body = JSON.stringify(params["lead"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AccessLogApi - functional programming interface
 */
export const AccessLogApiFp = {
    /** 
     * @param lead 
     */
    accessLogLog(params: { "lead": AccessLogModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccessLogApiFetchParamCreator.accessLogLog(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param lead 
     */
    accessLogPostLead(params: { "lead": SessionTrackModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AccessLogApiFetchParamCreator.accessLogPostLead(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AccessLogApi - object-oriented interface
 */
export class AccessLogApi extends BaseAPI {
    /** 
     * @param lead 
     */
    accessLogLog(params: {  "lead": AccessLogModel; }, options?: any) {
        return AccessLogApiFp.accessLogLog(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param lead 
     */
    accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any) {
        return AccessLogApiFp.accessLogPostLead(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AccessLogApi - factory interface
 */
export const AccessLogApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param lead 
         */
        accessLogLog(params: {  "lead": AccessLogModel; }, options?: any) {
            return AccessLogApiFp.accessLogLog(params, options)(fetch, basePath);
        },
        /** 
         * @param lead 
         */
        accessLogPostLead(params: {  "lead": SessionTrackModel; }, options?: any) {
            return AccessLogApiFp.accessLogPostLead(params, options)(fetch, basePath);
        },
    };
};


/**
 * AchievementApi - fetch parameter creator
 */
export const AchievementApiFetchParamCreator = {
    /** 
     * @param userId 
     */
    achievementGetAchievementForUser(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling achievementGetAchievementForUser");
        }
        const baseUrl = `/api/contest/{userId}/achievements`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling achievementGetLeaderboardForUser");
        }
        const baseUrl = `/api/contest/{userId}/leaderboard`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AchievementApi - functional programming interface
 */
export const AchievementApiFp = {
    /** 
     * @param userId 
     */
    achievementGetAchievementForUser(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AchievementModel>> {
        const fetchArgs = AchievementApiFetchParamCreator.achievementGetAchievementForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LeaderboardModel> {
        const fetchArgs = AchievementApiFetchParamCreator.achievementGetLeaderboardForUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AchievementApi - object-oriented interface
 */
export class AchievementApi extends BaseAPI {
    /** 
     * @param userId 
     */
    achievementGetAchievementForUser(params: {  "userId": string; }, options?: any) {
        return AchievementApiFp.achievementGetAchievementForUser(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userId 
     */
    achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any) {
        return AchievementApiFp.achievementGetLeaderboardForUser(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AchievementApi - factory interface
 */
export const AchievementApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userId 
         */
        achievementGetAchievementForUser(params: {  "userId": string; }, options?: any) {
            return AchievementApiFp.achievementGetAchievementForUser(params, options)(fetch, basePath);
        },
        /** 
         * @param userId 
         */
        achievementGetLeaderboardForUser(params: {  "userId": string; }, options?: any) {
            return AchievementApiFp.achievementGetLeaderboardForUser(params, options)(fetch, basePath);
        },
    };
};


/**
 * AddressApi - fetch parameter creator
 */
export const AddressApiFetchParamCreator = {
    /** 
     * Deletes a user&#39;s stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionDeleteAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressSessionDeleteAddress");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/{addressId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionGetAddressDictionary");
        }
        const baseUrl = `/api/session/{sessionId}/user-address`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionGetAddressList");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Adds an address to a user&#39;s account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionPostAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressSessionPostAddress");
        }
        const baseUrl = `/api/session/{sessionId}/user-address`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates a user&#39;s stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling addressSessionPutAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressSessionPutAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressSessionPutAddress");
        }
        const baseUrl = `/api/session/{sessionId}/user-address/{addressId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Deletes a user&#39;s stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserDeleteAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressUserDeleteAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address/{addressId}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserGetAddressDictionary");
        }
        const baseUrl = `/api/user/{userGuid}/address`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Adds an address to a user&#39;s account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserPostAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressUserPostAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates a user&#39;s stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling addressUserPutAddress");
        }
        // verify required parameter "addressId" is set
        if (params["addressId"] == null) {
            throw new Error("Missing required parameter addressId when calling addressUserPutAddress");
        }
        // verify required parameter "address" is set
        if (params["address"] == null) {
            throw new Error("Missing required parameter address when calling addressUserPutAddress");
        }
        const baseUrl = `/api/user/{userGuid}/address/{addressId}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"addressId"}}`, `${ params["addressId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["address"]) {
            fetchOptions.body = JSON.stringify(params["address"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AddressApi - functional programming interface
 */
export const AddressApiFp = {
    /** 
     * Deletes a user&#39;s stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: { "sessionId": string; "addressId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionDeleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NhAddressModel; }> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionGetAddressDictionary(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhAddressModel>> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionGetAddressList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Adds an address to a user&#39;s account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress(params: { "sessionId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddressModelResponse> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionPostAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates a user&#39;s stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: { "sessionId": string; "addressId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AddressModelResponse> {
        const fetchArgs = AddressApiFetchParamCreator.addressSessionPutAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Deletes a user&#39;s stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: { "userGuid": string; "addressId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserDeleteAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: NhAddressModel; }> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserGetAddressDictionary(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Adds an address to a user&#39;s account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: { "userGuid": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserPostAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates a user&#39;s stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: { "userGuid": string; "addressId": string; "address": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AddressApiFetchParamCreator.addressUserPutAddress(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AddressApi - object-oriented interface
 */
export class AddressApi extends BaseAPI {
    /** 
     * Deletes a user&#39;s stored address.
     * @param sessionId 
     * @param addressId Address id to delete.
     */
    addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any) {
        return AddressApiFp.addressSessionDeleteAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any) {
        return AddressApiFp.addressSessionGetAddressDictionary(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the addresses for a specified user.
     * @param sessionId sessionId of the user to get addresses from.
     */
    addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any) {
        return AddressApiFp.addressSessionGetAddressList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Adds an address to a user&#39;s account
     * @param sessionId User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressSessionPostAddress(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressSessionPostAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates a user&#39;s stored address.
     * @param sessionId Session id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressSessionPutAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Deletes a user&#39;s stored address.
     * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
     * @param addressId Address id to delete.
     */
    addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any) {
        return AddressApiFp.addressUserDeleteAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the addresses for a specified user.
     * @param userGuid Id of the user to get addresses from.
     */
    addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any) {
        return AddressApiFp.addressUserGetAddressDictionary(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Adds an address to a user&#39;s account
     * @param userGuid User id to add the address to
     * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
     */
    addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressUserPostAddress(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates a user&#39;s stored address.
     * @param userGuid User id that owns the address
     * @param addressId specifies the address Id to update
     * @param address Address to update, with updated data.
     */
    addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
        return AddressApiFp.addressUserPutAddress(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AddressApi - factory interface
 */
export const AddressApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Deletes a user&#39;s stored address.
         * @param sessionId 
         * @param addressId Address id to delete.
         */
        addressSessionDeleteAddress(params: {  "sessionId": string; "addressId": string; }, options?: any) {
            return AddressApiFp.addressSessionDeleteAddress(params, options)(fetch, basePath);
        },
        /** 
         * Gets the addresses for a specified user.
         * @param sessionId sessionId of the user to get addresses from.
         */
        addressSessionGetAddressDictionary(params: {  "sessionId": string; }, options?: any) {
            return AddressApiFp.addressSessionGetAddressDictionary(params, options)(fetch, basePath);
        },
        /** 
         * Gets the addresses for a specified user.
         * @param sessionId sessionId of the user to get addresses from.
         */
        addressSessionGetAddressList(params: {  "sessionId": string; }, options?: any) {
            return AddressApiFp.addressSessionGetAddressList(params, options)(fetch, basePath);
        },
        /** 
         * Adds an address to a user&#39;s account
         * @param sessionId User id to add the address to
         * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
         */
        addressSessionPostAddress(params: {  "sessionId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressSessionPostAddress(params, options)(fetch, basePath);
        },
        /** 
         * Updates a user&#39;s stored address.
         * @param sessionId Session id that owns the address
         * @param addressId specifies the address Id to update
         * @param address Address to update, with updated data.
         */
        addressSessionPutAddress(params: {  "sessionId": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressSessionPutAddress(params, options)(fetch, basePath);
        },
        /** 
         * Deletes a user&#39;s stored address.
         * @param userGuid Id of the user to delete the address from (for verification against the owner of the address Id,  specified in the request body &#39;address&#39;)
         * @param addressId Address id to delete.
         */
        addressUserDeleteAddress(params: {  "userGuid": string; "addressId": string; }, options?: any) {
            return AddressApiFp.addressUserDeleteAddress(params, options)(fetch, basePath);
        },
        /** 
         * Gets the addresses for a specified user.
         * @param userGuid Id of the user to get addresses from.
         */
        addressUserGetAddressDictionary(params: {  "userGuid": string; }, options?: any) {
            return AddressApiFp.addressUserGetAddressDictionary(params, options)(fetch, basePath);
        },
        /** 
         * Adds an address to a user&#39;s account
         * @param userGuid User id to add the address to
         * @param address Address data to add (you can leave the &#39;id&#39; field here empty/zero because it&#39;s auto-generated by  the database)
         */
        addressUserPostAddress(params: {  "userGuid": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressUserPostAddress(params, options)(fetch, basePath);
        },
        /** 
         * Updates a user&#39;s stored address.
         * @param userGuid User id that owns the address
         * @param addressId specifies the address Id to update
         * @param address Address to update, with updated data.
         */
        addressUserPutAddress(params: {  "userGuid": string; "addressId": string; "address": NhAddressModel; }, options?: any) {
            return AddressApiFp.addressUserPutAddress(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdjustmentApi - fetch parameter creator
 */
export const AdjustmentApiFetchParamCreator = {
    /** 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adjustmentCreateAdjustmentForSku");
        }
        const baseUrl = `/api/admin/adjustment/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    adjustmentExecAdjustment(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adjustmentExecAdjustment");
        }
        const baseUrl = `/api/admin/adjustment/exec/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdjustmentApi - functional programming interface
 */
export const AdjustmentApiFp = {
    /** 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: { "model": NhAdjustment;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAdjustment> {
        const fetchArgs = AdjustmentApiFetchParamCreator.adjustmentCreateAdjustmentForSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    adjustmentExecAdjustment(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdjustmentApiFetchParamCreator.adjustmentExecAdjustment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdjustmentApi - object-oriented interface
 */
export class AdjustmentApi extends BaseAPI {
    /** 
     * @param model 
     */
    adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any) {
        return AdjustmentApiFp.adjustmentCreateAdjustmentForSku(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    adjustmentExecAdjustment(params: {  "id": string; }, options?: any) {
        return AdjustmentApiFp.adjustmentExecAdjustment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdjustmentApi - factory interface
 */
export const AdjustmentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param model 
         */
        adjustmentCreateAdjustmentForSku(params: {  "model": NhAdjustment; }, options?: any) {
            return AdjustmentApiFp.adjustmentCreateAdjustmentForSku(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        adjustmentExecAdjustment(params: {  "id": string; }, options?: any) {
            return AdjustmentApiFp.adjustmentExecAdjustment(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminCampaignApi - fetch parameter creator
 */
export const AdminCampaignApiFetchParamCreator = {
    /** 
     * @param campaignId 
     */
    adminCampaignExport(params: {  "campaignId": number; }, options?: any): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling adminCampaignExport");
        }
        const baseUrl = `/api/admin/campaign/export/{campaignId}`
            .replace(`{${"campaignId"}}`, `${ params["campaignId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param campaignId 
     */
    adminCampaignPick(params: {  "campaignId": number; }, options?: any): FetchArgs {
        // verify required parameter "campaignId" is set
        if (params["campaignId"] == null) {
            throw new Error("Missing required parameter campaignId when calling adminCampaignPick");
        }
        const baseUrl = `/api/admin/campaign/pick/{campaignId}`
            .replace(`{${"campaignId"}}`, `${ params["campaignId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminCampaignApi - functional programming interface
 */
export const AdminCampaignApiFp = {
    /** 
     * @param campaignId 
     */
    adminCampaignExport(params: { "campaignId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CampaignExportModel>> {
        const fetchArgs = AdminCampaignApiFetchParamCreator.adminCampaignExport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param campaignId 
     */
    adminCampaignPick(params: { "campaignId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignExportModel> {
        const fetchArgs = AdminCampaignApiFetchParamCreator.adminCampaignPick(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminCampaignApi - object-oriented interface
 */
export class AdminCampaignApi extends BaseAPI {
    /** 
     * @param campaignId 
     */
    adminCampaignExport(params: {  "campaignId": number; }, options?: any) {
        return AdminCampaignApiFp.adminCampaignExport(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param campaignId 
     */
    adminCampaignPick(params: {  "campaignId": number; }, options?: any) {
        return AdminCampaignApiFp.adminCampaignPick(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminCampaignApi - factory interface
 */
export const AdminCampaignApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param campaignId 
         */
        adminCampaignExport(params: {  "campaignId": number; }, options?: any) {
            return AdminCampaignApiFp.adminCampaignExport(params, options)(fetch, basePath);
        },
        /** 
         * @param campaignId 
         */
        adminCampaignPick(params: {  "campaignId": number; }, options?: any) {
            return AdminCampaignApiFp.adminCampaignPick(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminDeliveryApi - fetch parameter creator
 */
export const AdminDeliveryApiFetchParamCreator = {
    /** 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminDeliveryCreateDelivery");
        }
        const baseUrl = `/api/admin/SkuDelivery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    adminDeliveryListDeliveries(options?: any): FetchArgs {
        const baseUrl = `/api/admin/SkuDelivery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminDeliveryApi - functional programming interface
 */
export const AdminDeliveryApiFp = {
    /** 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: { "model": AdminSkuDelivery;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminSkuDelivery> {
        const fetchArgs = AdminDeliveryApiFetchParamCreator.adminDeliveryCreateDelivery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    adminDeliveryListDeliveries(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhSkuDelivery>> {
        const fetchArgs = AdminDeliveryApiFetchParamCreator.adminDeliveryListDeliveries(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminDeliveryApi - object-oriented interface
 */
export class AdminDeliveryApi extends BaseAPI {
    /** 
     * @param model 
     */
    adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any) {
        return AdminDeliveryApiFp.adminDeliveryCreateDelivery(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    adminDeliveryListDeliveries(options?: any) {
        return AdminDeliveryApiFp.adminDeliveryListDeliveries(options)(this.fetch, this.basePath);
    }
};

/**
 * AdminDeliveryApi - factory interface
 */
export const AdminDeliveryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param model 
         */
        adminDeliveryCreateDelivery(params: {  "model": AdminSkuDelivery; }, options?: any) {
            return AdminDeliveryApiFp.adminDeliveryCreateDelivery(params, options)(fetch, basePath);
        },
        /** 
         */
        adminDeliveryListDeliveries(options?: any) {
            return AdminDeliveryApiFp.adminDeliveryListDeliveries(options)(fetch, basePath);
        },
    };
};


/**
 * AdminOrderApi - fetch parameter creator
 */
export const AdminOrderApiFetchParamCreator = {
    /** 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: {  "fix"?: boolean; "orderGuid"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/misallocations`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "fix": params["fix"],
            "orderGuid": params["orderGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Retrieves detail, including bottle info, about a specific order.
     * @param id Order id.
     */
    adminOrderArOrderById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderById");
        }
        const baseUrl = `/api/admin/orders/byId/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderCaptureSingle");
        }
        const baseUrl = `/api/captureOrder/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     * @param details 
     */
    adminOrderArOrderPromoApply(params: {  "id": string; "details": OrderModelExtended; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderPromoApply");
        }
        // verify required parameter "details" is set
        if (params["details"] == null) {
            throw new Error("Missing required parameter details when calling adminOrderArOrderPromoApply");
        }
        const baseUrl = `/api/admin/orders/byId/{id}/promocode`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates the order status of one or more order(s).
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: {  "details": Array<NhOrderModel>; }, options?: any): FetchArgs {
        // verify required parameter "details" is set
        if (params["details"] == null) {
            throw new Error("Missing required parameter details when calling adminOrderArOrderPut");
        }
        const baseUrl = `/api/admin/orders/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["details"]) {
            fetchOptions.body = JSON.stringify(params["details"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: {  "id": string; "background"?: boolean; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderReject");
        }
        const baseUrl = `/api/admin/orders/byId/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "background": params["background"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    adminOrderArOrderRepick(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminOrderArOrderRepick");
        }
        const baseUrl = `/api/admin/orders/byId/{id}/repick`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/orders/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminOrderApi - functional programming interface
 */
export const AdminOrderApiFp = {
    /** 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: { "fix"?: boolean; "orderGuid"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArFindMisallocations(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Retrieves detail, including bottle info, about a specific order.
     * @param id Order id.
     */
    adminOrderArOrderById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderModel> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderCaptureSingle(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     * @param details 
     */
    adminOrderArOrderPromoApply(params: { "id": string; "details": OrderModelExtended;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderPromoApply(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates the order status of one or more order(s).
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: { "details": Array<NhOrderModel>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: { "id": string; "background"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderModel> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderReject(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    adminOrderArOrderRepick(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2ManifestEntity>> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderRepick(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: { "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhOrderModel>> {
        const fetchArgs = AdminOrderApiFetchParamCreator.adminOrderArOrderSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminOrderApi - object-oriented interface
 */
export class AdminOrderApi extends BaseAPI {
    /** 
     * @param fix 
     * @param orderGuid 
     */
    adminOrderArFindMisallocations(params: {  "fix"?: boolean; "orderGuid"?: string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArFindMisallocations(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Retrieves detail, including bottle info, about a specific order.
     * @param id Order id.
     */
    adminOrderArOrderById(params: {  "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    adminOrderArOrderCaptureSingle(params: {  "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderCaptureSingle(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     * @param details 
     */
    adminOrderArOrderPromoApply(params: {  "id": string; "details": OrderModelExtended; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderPromoApply(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates the order status of one or more order(s).
     * @param details The orders to update (order id and status must be filled in).
     */
    adminOrderArOrderPut(params: {  "details": Array<NhOrderModel>; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     * @param background 
     */
    adminOrderArOrderReject(params: {  "id": string; "background"?: boolean; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderReject(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    adminOrderArOrderRepick(params: {  "id": string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderRepick(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
     * @param skip Skip.
     * @param take Take.
     * @param search Search.
     */
    adminOrderArOrderSearch(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return AdminOrderApiFp.adminOrderArOrderSearch(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminOrderApi - factory interface
 */
export const AdminOrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param fix 
         * @param orderGuid 
         */
        adminOrderArFindMisallocations(params: {  "fix"?: boolean; "orderGuid"?: string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArFindMisallocations(params, options)(fetch, basePath);
        },
        /** 
         * Retrieves detail, including bottle info, about a specific order.
         * @param id Order id.
         */
        adminOrderArOrderById(params: {  "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderById(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        adminOrderArOrderCaptureSingle(params: {  "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderCaptureSingle(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         * @param details 
         */
        adminOrderArOrderPromoApply(params: {  "id": string; "details": OrderModelExtended; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderPromoApply(params, options)(fetch, basePath);
        },
        /** 
         * Updates the order status of one or more order(s).
         * @param details The orders to update (order id and status must be filled in).
         */
        adminOrderArOrderPut(params: {  "details": Array<NhOrderModel>; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderPut(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         * @param background 
         */
        adminOrderArOrderReject(params: {  "id": string; "background"?: boolean; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderReject(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        adminOrderArOrderRepick(params: {  "id": string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderRepick(params, options)(fetch, basePath);
        },
        /** 
         * Gets a list of orders, with paging information. Can also filter the orders based on a search criterion. Bottle  information is not available.
         * @param skip Skip.
         * @param take Take.
         * @param search Search.
         */
        adminOrderArOrderSearch(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return AdminOrderApiFp.adminOrderArOrderSearch(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminPromoCodeApi - fetch parameter creator
 */
export const AdminPromoCodeApiFetchParamCreator = {
    /** 
     * @param amount 
     * @param hours 
     */
    adminPromoCodeAddCreditForUsers(params: {  "amount": number; "hours": number; }, options?: any): FetchArgs {
        // verify required parameter "amount" is set
        if (params["amount"] == null) {
            throw new Error("Missing required parameter amount when calling adminPromoCodeAddCreditForUsers");
        }
        // verify required parameter "hours" is set
        if (params["hours"] == null) {
            throw new Error("Missing required parameter hours when calling adminPromoCodeAddCreditForUsers");
        }
        const baseUrl = `/api/admin/promo/forAllUsers`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "amount": params["amount"],
            "hours": params["hours"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Deactivates a promo code so it can&#39;t be used.
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: {  "code": string; }, options?: any): FetchArgs {
        // verify required parameter "code" is set
        if (params["code"] == null) {
            throw new Error("Missing required parameter code when calling adminPromoCodeDelete");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "code": params["code"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets a single promo code, or a list of promo codes.
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: {  "search": string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling adminPromoCodeGet");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Creates a new promo code.
     * @param model 
     */
    adminPromoCodePost(params: {  "model": NhPromoCodeModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminPromoCodePost");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates a new promo code.
     * @param model 
     */
    adminPromoCodePut(params: {  "model": NhPromoCodeModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling adminPromoCodePut");
        }
        const baseUrl = `/api/admin/promo`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminPromoCodeApi - functional programming interface
 */
export const AdminPromoCodeApiFp = {
    /** 
     * @param amount 
     * @param hours 
     */
    adminPromoCodeAddCreditForUsers(params: { "amount": number; "hours": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodeAddCreditForUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Deactivates a promo code so it can&#39;t be used.
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: { "code": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodeDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets a single promo code, or a list of promo codes.
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: { "search": string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodeGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Creates a new promo code.
     * @param model 
     */
    adminPromoCodePost(params: { "model": NhPromoCodeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodePost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates a new promo code.
     * @param model 
     */
    adminPromoCodePut(params: { "model": NhPromoCodeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminPromoCodeApiFetchParamCreator.adminPromoCodePut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminPromoCodeApi - object-oriented interface
 */
export class AdminPromoCodeApi extends BaseAPI {
    /** 
     * @param amount 
     * @param hours 
     */
    adminPromoCodeAddCreditForUsers(params: {  "amount": number; "hours": number; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodeAddCreditForUsers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Deactivates a promo code so it can&#39;t be used.
     * @param code Promo code to deactivate.
     */
    adminPromoCodeDelete(params: {  "code": string; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodeDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets a single promo code, or a list of promo codes.
     * @param search 
     * @param skip 
     * @param take 
     */
    adminPromoCodeGet(params: {  "search": string; "skip"?: number; "take"?: number; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodeGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Creates a new promo code.
     * @param model 
     */
    adminPromoCodePost(params: {  "model": NhPromoCodeModel; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodePost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates a new promo code.
     * @param model 
     */
    adminPromoCodePut(params: {  "model": NhPromoCodeModel; }, options?: any) {
        return AdminPromoCodeApiFp.adminPromoCodePut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminPromoCodeApi - factory interface
 */
export const AdminPromoCodeApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param amount 
         * @param hours 
         */
        adminPromoCodeAddCreditForUsers(params: {  "amount": number; "hours": number; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodeAddCreditForUsers(params, options)(fetch, basePath);
        },
        /** 
         * Deactivates a promo code so it can&#39;t be used.
         * @param code Promo code to deactivate.
         */
        adminPromoCodeDelete(params: {  "code": string; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodeDelete(params, options)(fetch, basePath);
        },
        /** 
         * Gets a single promo code, or a list of promo codes.
         * @param search 
         * @param skip 
         * @param take 
         */
        adminPromoCodeGet(params: {  "search": string; "skip"?: number; "take"?: number; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodeGet(params, options)(fetch, basePath);
        },
        /** 
         * Creates a new promo code.
         * @param model 
         */
        adminPromoCodePost(params: {  "model": NhPromoCodeModel; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodePost(params, options)(fetch, basePath);
        },
        /** 
         * Updates a new promo code.
         * @param model 
         */
        adminPromoCodePut(params: {  "model": NhPromoCodeModel; }, options?: any) {
            return AdminPromoCodeApiFp.adminPromoCodePut(params, options)(fetch, basePath);
        },
    };
};


/**
 * AdminReferralApi - fetch parameter creator
 */
export const AdminReferralApiFetchParamCreator = {
    /** 
     */
    adminReferralGet(options?: any): FetchArgs {
        const baseUrl = `/api/admin/referral`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: {  "userId": string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling adminReferralGet_1");
        }
        const baseUrl = `/api/admin/referrals/list/byUser/{userId}`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Sets the referral of user. Doesn&#39;t automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param id User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: {  "id": number; "data": AdminReferralModel; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling adminReferralPost");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling adminReferralPost");
        }
        const baseUrl = `/api/admin/referral/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * AdminReferralApi - functional programming interface
 */
export const AdminReferralApiFp = {
    /** 
     */
    adminReferralGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: { "userId": string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserReferralModel>> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Sets the referral of user. Doesn&#39;t automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param id User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: { "id": number; "data": AdminReferralModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = AdminReferralApiFetchParamCreator.adminReferralPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * AdminReferralApi - object-oriented interface
 */
export class AdminReferralApi extends BaseAPI {
    /** 
     */
    adminReferralGet(options?: any) {
        return AdminReferralApiFp.adminReferralGet(options)(this.fetch, this.basePath);
    }
    /** 
     * @param userId 
     * @param skip 
     * @param take 
     */
    adminReferralGet_1(params: {  "userId": string; "skip"?: number; "take"?: number; }, options?: any) {
        return AdminReferralApiFp.adminReferralGet_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Sets the referral of user. Doesn&#39;t automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
     * @param id User id
     * @param data Email address of user to credit with referral
     */
    adminReferralPost(params: {  "id": number; "data": AdminReferralModel; }, options?: any) {
        return AdminReferralApiFp.adminReferralPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * AdminReferralApi - factory interface
 */
export const AdminReferralApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         */
        adminReferralGet(options?: any) {
            return AdminReferralApiFp.adminReferralGet(options)(fetch, basePath);
        },
        /** 
         * @param userId 
         * @param skip 
         * @param take 
         */
        adminReferralGet_1(params: {  "userId": string; "skip"?: number; "take"?: number; }, options?: any) {
            return AdminReferralApiFp.adminReferralGet_1(params, options)(fetch, basePath);
        },
        /** 
         * Sets the referral of user. Doesn&#39;t automatically give  the bonus; the bonus must manually be added by the admin if the referred user already made first purchase. If the  referred user later  makes the first purchase, then the system will automatically credit the appropriate awards.
         * @param id User id
         * @param data Email address of user to credit with referral
         */
        adminReferralPost(params: {  "id": number; "data": AdminReferralModel; }, options?: any) {
            return AdminReferralApiFp.adminReferralPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * CampaignApi - fetch parameter creator
 */
export const CampaignApiFetchParamCreator = {
    /** 
     * @param id 
     * @param userId 
     */
    campaignGet(params: {  "id": number; "userId": number; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignGet");
        }
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling campaignGet");
        }
        const baseUrl = `/api/campaign/{id}/{userId}`
            .replace(`{${"id"}}`, `${ params["id"] }`)
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling campaignPostEntry");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling campaignPostEntry");
        }
        const baseUrl = `/api/campaign/{id}/entry`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CampaignApi - functional programming interface
 */
export const CampaignApiFp = {
    /** 
     * @param id 
     * @param userId 
     */
    campaignGet(params: { "id": number; "userId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CampaignApiModel> {
        const fetchArgs = CampaignApiFetchParamCreator.campaignGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: { "id": number; "model": CampaignEntryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CampaignApiFetchParamCreator.campaignPostEntry(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CampaignApi - object-oriented interface
 */
export class CampaignApi extends BaseAPI {
    /** 
     * @param id 
     * @param userId 
     */
    campaignGet(params: {  "id": number; "userId": number; }, options?: any) {
        return CampaignApiFp.campaignGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     * @param model 
     */
    campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any) {
        return CampaignApiFp.campaignPostEntry(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CampaignApi - factory interface
 */
export const CampaignApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param id 
         * @param userId 
         */
        campaignGet(params: {  "id": number; "userId": number; }, options?: any) {
            return CampaignApiFp.campaignGet(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         * @param model 
         */
        campaignPostEntry(params: {  "id": number; "model": CampaignEntryModel; }, options?: any) {
            return CampaignApiFp.campaignPostEntry(params, options)(fetch, basePath);
        },
    };
};


/**
 * CheckoutApiApi - fetch parameter creator
 */
export const CheckoutApiApiFetchParamCreator = {
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostShipmentFromSession");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostShipmentFromSession");
        }
        const baseUrl = `/api/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPostShipmentFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPostShipmentFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSession(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutFromSession");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutFromSession");
        }
        const baseUrl = `/api/session/{sessionId}/checkout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/checkout`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutShipmentFromSession");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutShipmentFromSession");
        }
        const baseUrl = `/api/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling checkoutApiPutShipmentFromSessionV3");
        }
        // verify required parameter "offerCheckoutInfo" is set
        if (params["offerCheckoutInfo"] == null) {
            throw new Error("Missing required parameter offerCheckoutInfo when calling checkoutApiPutShipmentFromSessionV3");
        }
        const baseUrl = `/api/v3/session/{sessionId}/ship`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["offerCheckoutInfo"]) {
            fetchOptions.body = JSON.stringify(params["offerCheckoutInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CheckoutApiApi - functional programming interface
 */
export const CheckoutApiApiFp = {
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSession(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostShipmentFromSession(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPostShipmentFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSession(params: { "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutFromSession(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultOfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSession(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutShipmentFromSession(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: { "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferCheckoutModel> {
        const fetchArgs = CheckoutApiApiFetchParamCreator.checkoutApiPutShipmentFromSessionV3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CheckoutApiApi - object-oriented interface
 */
export class CheckoutApiApi extends BaseAPI {
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostShipmentFromSession(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Process a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPostShipmentFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSession(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutFromSession(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Simulate a checkout operation.
     * @param sessionId 
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutFromSessionV3(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutShipmentFromSession(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Simulate a checkout operation.
     * @param sessionId Session ID.
     * @param offerCheckoutInfo The checkout information.
     */
    checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
        return CheckoutApiApiFp.checkoutApiPutShipmentFromSessionV3(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CheckoutApiApi - factory interface
 */
export const CheckoutApiApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Process a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostFromSessionV3(params, options)(fetch, basePath);
        },
        /** 
         * Process a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostShipmentFromSession(params, options)(fetch, basePath);
        },
        /** 
         * Process a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPostShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPostShipmentFromSessionV3(params, options)(fetch, basePath);
        },
        /** 
         * Simulate a checkout operation.
         * @param sessionId 
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutFromSession(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutFromSession(params, options)(fetch, basePath);
        },
        /** 
         * Simulate a checkout operation.
         * @param sessionId 
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": OfferCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutFromSessionV3(params, options)(fetch, basePath);
        },
        /** 
         * Simulate a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutShipmentFromSession(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutShipmentFromSession(params, options)(fetch, basePath);
        },
        /** 
         * Simulate a checkout operation.
         * @param sessionId Session ID.
         * @param offerCheckoutInfo The checkout information.
         */
        checkoutApiPutShipmentFromSessionV3(params: {  "sessionId": string; "offerCheckoutInfo": CloudCheckoutModel; }, options?: any) {
            return CheckoutApiApiFp.checkoutApiPutShipmentFromSessionV3(params, options)(fetch, basePath);
        },
    };
};


/**
 * CloudCellarApi - fetch parameter creator
 */
export const CloudCellarApiFetchParamCreator = {
    /** 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling cloudCellarGetApiCloudcellarSearch");
        }
        const baseUrl = `/api/v2/admin/cloudcellar`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userName 
     */
    cloudCellarGetV2(params: {  "userName": string; }, options?: any): FetchArgs {
        // verify required parameter "userName" is set
        if (params["userName"] == null) {
            throw new Error("Missing required parameter userName when calling cloudCellarGetV2");
        }
        const baseUrl = `/api/v2/cloudcellar/{userName}`
            .replace(`{${"userName"}}`, `${ params["userName"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cloudCellarHandleClaimPrize");
        }
        // verify required parameter "prize" is set
        if (params["prize"] == null) {
            throw new Error("Missing required parameter prize when calling cloudCellarHandleClaimPrize");
        }
        const baseUrl = `/api/session/{sessionId}/wordgame/{prize}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"prize"}}`, `${ params["prize"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling cloudCellarHandleGetLetters");
        }
        const baseUrl = `/api/session/{sessionId}/wordgame`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CloudCellarApi - functional programming interface
 */
export const CloudCellarApiFp = {
    /** 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: { "search": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudCellarV2> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarGetApiCloudcellarSearch(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userName 
     */
    cloudCellarGetV2(params: { "userName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CloudCellarV2> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarGetV2(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: { "sessionId": string; "prize": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WordGame> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarHandleClaimPrize(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WordGame> {
        const fetchArgs = CloudCellarApiFetchParamCreator.cloudCellarHandleGetLetters(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CloudCellarApi - object-oriented interface
 */
export class CloudCellarApi extends BaseAPI {
    /** 
     * @param search 
     */
    cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarGetApiCloudcellarSearch(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userName 
     */
    cloudCellarGetV2(params: {  "userName": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarGetV2(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param prize 
     */
    cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarHandleClaimPrize(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any) {
        return CloudCellarApiFp.cloudCellarHandleGetLetters(params, options)(this.fetch, this.basePath);
    }
};

/**
 * CloudCellarApi - factory interface
 */
export const CloudCellarApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param search 
         */
        cloudCellarGetApiCloudcellarSearch(params: {  "search": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarGetApiCloudcellarSearch(params, options)(fetch, basePath);
        },
        /** 
         * @param userName 
         */
        cloudCellarGetV2(params: {  "userName": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarGetV2(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param prize 
         */
        cloudCellarHandleClaimPrize(params: {  "sessionId": string; "prize": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarHandleClaimPrize(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        cloudCellarHandleGetLetters(params: {  "sessionId": string; }, options?: any) {
            return CloudCellarApiFp.cloudCellarHandleGetLetters(params, options)(fetch, basePath);
        },
    };
};


/**
 * CplSkuStockApi - fetch parameter creator
 */
export const CplSkuStockApiFetchParamCreator = {
    /** 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any): FetchArgs {
        // verify required parameter "overdue" is set
        if (params["overdue"] == null) {
            throw new Error("Missing required parameter overdue when calling cplSkuStockGetArrivals");
        }
        const baseUrl = `/api/admin/report/arrivals`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "overdue": params["overdue"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    cplSkuStockGetCplStock(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/cplstock`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: {  "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/deficit`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "beyondDays": params["beyondDays"],
            "qtyLessThan": params["qtyLessThan"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    cplSkuStockSkuSales(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/skusales`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    cplSkuStockUpdateCplStock(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/cplstock/update`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * CplSkuStockApi - functional programming interface
 */
export const CplSkuStockApiFp = {
    /** 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: { "overdue": boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuEntity>> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockGetArrivals(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    cplSkuStockGetCplStock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockGetCplStock(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: { "beyondDays"?: number; "qtyLessThan"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeficitItem>> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockHandleAdminReportDeficit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    cplSkuStockSkuSales(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuSaleItemModel>> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockSkuSales(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    cplSkuStockUpdateCplStock(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = CplSkuStockApiFetchParamCreator.cplSkuStockUpdateCplStock(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * CplSkuStockApi - object-oriented interface
 */
export class CplSkuStockApi extends BaseAPI {
    /** 
     * @param overdue 
     */
    cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any) {
        return CplSkuStockApiFp.cplSkuStockGetArrivals(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    cplSkuStockGetCplStock(options?: any) {
        return CplSkuStockApiFp.cplSkuStockGetCplStock(options)(this.fetch, this.basePath);
    }
    /** 
     * @param beyondDays 
     * @param qtyLessThan 
     */
    cplSkuStockHandleAdminReportDeficit(params: {  "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any) {
        return CplSkuStockApiFp.cplSkuStockHandleAdminReportDeficit(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    cplSkuStockSkuSales(options?: any) {
        return CplSkuStockApiFp.cplSkuStockSkuSales(options)(this.fetch, this.basePath);
    }
    /** 
     */
    cplSkuStockUpdateCplStock(options?: any) {
        return CplSkuStockApiFp.cplSkuStockUpdateCplStock(options)(this.fetch, this.basePath);
    }
};

/**
 * CplSkuStockApi - factory interface
 */
export const CplSkuStockApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param overdue 
         */
        cplSkuStockGetArrivals(params: {  "overdue": boolean; }, options?: any) {
            return CplSkuStockApiFp.cplSkuStockGetArrivals(params, options)(fetch, basePath);
        },
        /** 
         */
        cplSkuStockGetCplStock(options?: any) {
            return CplSkuStockApiFp.cplSkuStockGetCplStock(options)(fetch, basePath);
        },
        /** 
         * @param beyondDays 
         * @param qtyLessThan 
         */
        cplSkuStockHandleAdminReportDeficit(params: {  "beyondDays"?: number; "qtyLessThan"?: number; }, options?: any) {
            return CplSkuStockApiFp.cplSkuStockHandleAdminReportDeficit(params, options)(fetch, basePath);
        },
        /** 
         */
        cplSkuStockSkuSales(options?: any) {
            return CplSkuStockApiFp.cplSkuStockSkuSales(options)(fetch, basePath);
        },
        /** 
         */
        cplSkuStockUpdateCplStock(options?: any) {
            return CplSkuStockApiFp.cplSkuStockUpdateCplStock(options)(fetch, basePath);
        },
    };
};


/**
 * EmailMarketingApi - fetch parameter creator
 */
export const EmailMarketingApiFetchParamCreator = {
    /** 
     */
    emailMarketingHandleGet(options?: any): FetchArgs {
        const baseUrl = `/api/admin/v2/email/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    emailMarketingHandleGetAbandoned(options?: any): FetchArgs {
        const baseUrl = `/api/admin/v2/email/list/abandonedCheckout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: {  "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/v2/email/list/expiringCredits`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "send": params["send"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param message 
     */
    emailMarketingHandleSendPush(params: {  "message": string; }, options?: any): FetchArgs {
        // verify required parameter "message" is set
        if (params["message"] == null) {
            throw new Error("Missing required parameter message when calling emailMarketingHandleSendPush");
        }
        const baseUrl = `/api/admin/v2/email/push`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "message": params["message"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any): FetchArgs {
        // verify required parameter "email" is set
        if (params["email"] == null) {
            throw new Error("Missing required parameter email when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubCampaignId" is set
        if (params["unsubCampaignId"] == null) {
            throw new Error("Missing required parameter unsubCampaignId when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubCampaignTitle" is set
        if (params["unsubCampaignTitle"] == null) {
            throw new Error("Missing required parameter unsubCampaignTitle when calling emailMarketingHandleUnsub");
        }
        // verify required parameter "unsubReason" is set
        if (params["unsubReason"] == null) {
            throw new Error("Missing required parameter unsubReason when calling emailMarketingHandleUnsub");
        }
        const baseUrl = `/api/admin/v2/email/list/unsub`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "email": params["email"],
            "unsubCampaignId": params["unsubCampaignId"],
            "unsubCampaignTitle": params["unsubCampaignTitle"],
            "unsubReason": params["unsubReason"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any): FetchArgs {
        // verify required parameter "page" is set
        if (params["page"] == null) {
            throw new Error("Missing required parameter page when calling emailMarketingImportDotmailerIds");
        }
        const baseUrl = `/api/admin/v2/dotmailer/pull/{page}`
            .replace(`{${"page"}}`, `${ params["page"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: {  "toEmail": string; "toName": string; }, options?: any): FetchArgs {
        // verify required parameter "toEmail" is set
        if (params["toEmail"] == null) {
            throw new Error("Missing required parameter toEmail when calling emailMarketingSendTest");
        }
        // verify required parameter "toName" is set
        if (params["toName"] == null) {
            throw new Error("Missing required parameter toName when calling emailMarketingSendTest");
        }
        const baseUrl = `/api/admin/v2/email/test`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "toEmail": params["toEmail"],
            "toName": params["toName"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * EmailMarketingApi - functional programming interface
 */
export const EmailMarketingApiFp = {
    /** 
     */
    emailMarketingHandleGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    emailMarketingHandleGetAbandoned(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGetAbandoned(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: { "skip"?: number; "take"?: number; "send"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleGetExpiring(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param message 
     */
    emailMarketingHandleSendPush(params: { "message": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleSendPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: { "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingHandleUnsub(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: { "page": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingImportDotmailerIds(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: { "toEmail": string; "toName": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = EmailMarketingApiFetchParamCreator.emailMarketingSendTest(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * EmailMarketingApi - object-oriented interface
 */
export class EmailMarketingApi extends BaseAPI {
    /** 
     */
    emailMarketingHandleGet(options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGet(options)(this.fetch, this.basePath);
    }
    /** 
     */
    emailMarketingHandleGetAbandoned(options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGetAbandoned(options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     * @param send 
     */
    emailMarketingHandleGetExpiring(params: {  "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleGetExpiring(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param message 
     */
    emailMarketingHandleSendPush(params: {  "message": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleSendPush(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param email 
     * @param unsubCampaignId 
     * @param unsubCampaignTitle 
     * @param unsubReason 
     */
    emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingHandleUnsub(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param page 
     */
    emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingImportDotmailerIds(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param toEmail 
     * @param toName 
     */
    emailMarketingSendTest(params: {  "toEmail": string; "toName": string; }, options?: any) {
        return EmailMarketingApiFp.emailMarketingSendTest(params, options)(this.fetch, this.basePath);
    }
};

/**
 * EmailMarketingApi - factory interface
 */
export const EmailMarketingApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         */
        emailMarketingHandleGet(options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGet(options)(fetch, basePath);
        },
        /** 
         */
        emailMarketingHandleGetAbandoned(options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGetAbandoned(options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         * @param send 
         */
        emailMarketingHandleGetExpiring(params: {  "skip"?: number; "take"?: number; "send"?: boolean; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleGetExpiring(params, options)(fetch, basePath);
        },
        /** 
         * @param message 
         */
        emailMarketingHandleSendPush(params: {  "message": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleSendPush(params, options)(fetch, basePath);
        },
        /** 
         * @param email 
         * @param unsubCampaignId 
         * @param unsubCampaignTitle 
         * @param unsubReason 
         */
        emailMarketingHandleUnsub(params: {  "email": string; "unsubCampaignId": string; "unsubCampaignTitle": string; "unsubReason": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingHandleUnsub(params, options)(fetch, basePath);
        },
        /** 
         * @param page 
         */
        emailMarketingImportDotmailerIds(params: {  "page": number; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingImportDotmailerIds(params, options)(fetch, basePath);
        },
        /** 
         * @param toEmail 
         * @param toName 
         */
        emailMarketingSendTest(params: {  "toEmail": string; "toName": string; }, options?: any) {
            return EmailMarketingApiFp.emailMarketingSendTest(params, options)(fetch, basePath);
        },
    };
};


/**
 * InviteApi - fetch parameter creator
 */
export const InviteApiFetchParamCreator = {
    /** 
     * @param input 
     */
    inviteInviteByEmail(params: {  "input": InviteByEmailModel; }, options?: any): FetchArgs {
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling inviteInviteByEmail");
        }
        const baseUrl = `/api/invitebyemail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * InviteApi - functional programming interface
 */
export const InviteApiFp = {
    /** 
     * @param input 
     */
    inviteInviteByEmail(params: { "input": InviteByEmailModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = InviteApiFetchParamCreator.inviteInviteByEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * InviteApi - object-oriented interface
 */
export class InviteApi extends BaseAPI {
    /** 
     * @param input 
     */
    inviteInviteByEmail(params: {  "input": InviteByEmailModel; }, options?: any) {
        return InviteApiFp.inviteInviteByEmail(params, options)(this.fetch, this.basePath);
    }
};

/**
 * InviteApi - factory interface
 */
export const InviteApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param input 
         */
        inviteInviteByEmail(params: {  "input": InviteByEmailModel; }, options?: any) {
            return InviteApiFp.inviteInviteByEmail(params, options)(fetch, basePath);
        },
    };
};


/**
 * ItemDetailApi - fetch parameter creator
 */
export const ItemDetailApiFetchParamCreator = {
    /** 
     * @param content 
     */
    itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailDelete");
        }
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any): FetchArgs {
        // verify required parameter "itemSef" is set
        if (params["itemSef"] == null) {
            throw new Error("Missing required parameter itemSef when calling itemDetailGetBySefOrSku");
        }
        const baseUrl = `/api/v2/itemdetail/{itemSef}`
            .replace(`{${"itemSef"}}`, `${ params["itemSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any): FetchArgs {
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling itemDetailMergeItemDetailHandler");
        }
        const baseUrl = `/api/v2/itemdetail/merge`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "input": params["input"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     */
    itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPost");
        }
        const baseUrl = `/api/v2/itemdetail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any): FetchArgs {
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling itemDetailPostItemDetailUploadImage");
        }
        const baseUrl = `/api/v2/itemdetail/uploadImage`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any): FetchArgs {
        // verify required parameter "itemSef" is set
        if (params["itemSef"] == null) {
            throw new Error("Missing required parameter itemSef when calling itemDetailPut");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling itemDetailPut");
        }
        const baseUrl = `/api/v2/itemdetail/{itemSef}`
            .replace(`{${"itemSef"}}`, `${ params["itemSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ItemDetailApi - functional programming interface
 */
export const ItemDetailApiFp = {
    /** 
     * @param content 
     */
    itemDetailDelete(params: { "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: { "itemSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailGetBySefOrSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    itemDetailListItemDetail(params: { "search"?: string; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailList> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailListItemDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: { "input": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailMergeItemDetailHandler(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     */
    itemDetailPost(params: { "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: { "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPostItemDetailUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: { "itemSef": string; "content": ItemDetailEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ItemDetailEntity> {
        const fetchArgs = ItemDetailApiFetchParamCreator.itemDetailPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ItemDetailApi - object-oriented interface
 */
export class ItemDetailApi extends BaseAPI {
    /** 
     * @param content 
     */
    itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param itemSef 
     */
    itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any) {
        return ItemDetailApiFp.itemDetailGetBySefOrSku(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; }, options?: any) {
        return ItemDetailApiFp.itemDetailListItemDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param input 
     */
    itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any) {
        return ItemDetailApiFp.itemDetailMergeItemDetailHandler(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     */
    itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param file 
     */
    itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any) {
        return ItemDetailApiFp.itemDetailPostItemDetailUploadImage(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param itemSef 
     * @param content 
     */
    itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
        return ItemDetailApiFp.itemDetailPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ItemDetailApi - factory interface
 */
export const ItemDetailApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param content 
         */
        itemDetailDelete(params: {  "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param itemSef 
         */
        itemDetailGetBySefOrSku(params: {  "itemSef": string; }, options?: any) {
            return ItemDetailApiFp.itemDetailGetBySefOrSku(params, options)(fetch, basePath);
        },
        /** 
         * @param search 
         * @param skip 
         * @param take 
         */
        itemDetailListItemDetail(params: {  "search"?: string; "skip"?: number; "take"?: number; }, options?: any) {
            return ItemDetailApiFp.itemDetailListItemDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param input 
         */
        itemDetailMergeItemDetailHandler(params: {  "input": string; }, options?: any) {
            return ItemDetailApiFp.itemDetailMergeItemDetailHandler(params, options)(fetch, basePath);
        },
        /** 
         * @param content 
         */
        itemDetailPost(params: {  "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPost(params, options)(fetch, basePath);
        },
        /** 
         * @param file 
         */
        itemDetailPostItemDetailUploadImage(params: {  "file": any; }, options?: any) {
            return ItemDetailApiFp.itemDetailPostItemDetailUploadImage(params, options)(fetch, basePath);
        },
        /** 
         * @param itemSef 
         * @param content 
         */
        itemDetailPut(params: {  "itemSef": string; "content": ItemDetailEntity; }, options?: any) {
            return ItemDetailApiFp.itemDetailPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * KeyMetricsApi - fetch parameter creator
 */
export const KeyMetricsApiFetchParamCreator = {
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/usersummary`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "utmCampaign": params["utmCampaign"],
            "utmSource": params["utmSource"],
            "utmMedium": params["utmMedium"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/buyToShip`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    keyMetricsGetAdminReportOfferStats(options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/names`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any): FetchArgs {
        // verify required parameter "reportName" is set
        if (params["reportName"] == null) {
            throw new Error("Missing required parameter reportName when calling keyMetricsGetAdminReportOfferStats_1");
        }
        const baseUrl = `/api/admin/report/names/{reportName}`
            .replace(`{${"reportName"}}`, `${ params["reportName"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "startDate": params["startDate"],
            "endDate": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any): FetchArgs {
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling keyMetricsGetAdminReportPromo");
        }
        const baseUrl = `/api/admin/report/promo`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "promoCode": params["promoCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    keyMetricsGetCohortAnalysis(options?: any): FetchArgs {
        const baseUrl = `/api/admin/cohorts`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/report/ltv`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "utmCampaign": params["utmCampaign"],
            "utmSource": params["utmSource"],
            "utmMedium": params["utmMedium"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any): FetchArgs {
        // verify required parameter "startDate" is set
        if (params["startDate"] == null) {
            throw new Error("Missing required parameter startDate when calling keyMetricsGet_2");
        }
        // verify required parameter "endDate" is set
        if (params["endDate"] == null) {
            throw new Error("Missing required parameter endDate when calling keyMetricsGet_2");
        }
        const baseUrl = `/keymetrics`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "startDate": params["startDate"],
            "endDate": params["endDate"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * KeyMetricsApi - functional programming interface
 */
export const KeyMetricsApiFp = {
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: { "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserSummaryViewRecord>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportBuyToShip(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    keyMetricsGetAdminReportOfferStats(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportOfferStats(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: { "reportName": string; "startDate"?: Date; "endDate"?: Date;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportOfferStats_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: { "promoCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetAdminReportPromo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    keyMetricsGetCohortAnalysis(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Cohort>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetCohortAnalysis(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: { "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserLifetimeViewRecord>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGetLtvReport(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: { "startDate": Date; "endDate": Date;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<KpiItem>> {
        const fetchArgs = KeyMetricsApiFetchParamCreator.keyMetricsGet_2(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * KeyMetricsApi - object-oriented interface
 */
export class KeyMetricsApi extends BaseAPI {
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    keyMetricsGetAdminReportBuyToShip(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportBuyToShip(options)(this.fetch, this.basePath);
    }
    /** 
     */
    keyMetricsGetAdminReportOfferStats(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats(options)(this.fetch, this.basePath);
    }
    /** 
     * @param reportName 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param promoCode 
     */
    keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetAdminReportPromo(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    keyMetricsGetCohortAnalysis(options?: any) {
        return KeyMetricsApiFp.keyMetricsGetCohortAnalysis(options)(this.fetch, this.basePath);
    }
    /** 
     * @param utmCampaign 
     * @param utmSource 
     * @param utmMedium 
     */
    keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGetLtvReport(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param startDate 
     * @param endDate 
     */
    keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any) {
        return KeyMetricsApiFp.keyMetricsGet_2(params, options)(this.fetch, this.basePath);
    }
};

/**
 * KeyMetricsApi - factory interface
 */
export const KeyMetricsApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param utmCampaign 
         * @param utmSource 
         * @param utmMedium 
         */
        keyMetricsGet(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGet(params, options)(fetch, basePath);
        },
        /** 
         */
        keyMetricsGetAdminReportBuyToShip(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportBuyToShip(options)(fetch, basePath);
        },
        /** 
         */
        keyMetricsGetAdminReportOfferStats(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats(options)(fetch, basePath);
        },
        /** 
         * @param reportName 
         * @param startDate 
         * @param endDate 
         */
        keyMetricsGetAdminReportOfferStats_1(params: {  "reportName": string; "startDate"?: Date; "endDate"?: Date; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportOfferStats_1(params, options)(fetch, basePath);
        },
        /** 
         * @param promoCode 
         */
        keyMetricsGetAdminReportPromo(params: {  "promoCode": string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetAdminReportPromo(params, options)(fetch, basePath);
        },
        /** 
         */
        keyMetricsGetCohortAnalysis(options?: any) {
            return KeyMetricsApiFp.keyMetricsGetCohortAnalysis(options)(fetch, basePath);
        },
        /** 
         * @param utmCampaign 
         * @param utmSource 
         * @param utmMedium 
         */
        keyMetricsGetLtvReport(params: {  "utmCampaign"?: string; "utmSource"?: string; "utmMedium"?: string; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGetLtvReport(params, options)(fetch, basePath);
        },
        /** 
         * @param startDate 
         * @param endDate 
         */
        keyMetricsGet_2(params: {  "startDate": Date; "endDate": Date; }, options?: any) {
            return KeyMetricsApiFp.keyMetricsGet_2(params, options)(fetch, basePath);
        },
    };
};


/**
 * ManifestAdminApi - fetch parameter creator
 */
export const ManifestAdminApiFetchParamCreator = {
    /** 
     * @param userId 
     * @param shipped 
     * @param skip 
     * @param take 
     */
    manifestAdminGet(params: {  "userId": string; "shipped": boolean; "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling manifestAdminGet");
        }
        // verify required parameter "shipped" is set
        if (params["shipped"] == null) {
            throw new Error("Missing required parameter shipped when calling manifestAdminGet");
        }
        const baseUrl = `/api/admin/manifests/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "userId": params["userId"],
            "shipped": params["shipped"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    manifestAdminGetClaimGiftManifest(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling manifestAdminGetClaimGiftManifest");
        }
        const baseUrl = `/api/admin/manifests/claimGiftCard`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "id": params["id"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param manifestId 
     * @param isSuspended 
     * @param reason 
     */
    manifestAdminGetSuspend(params: {  "manifestId": string; "isSuspended": boolean; "reason": string; }, options?: any): FetchArgs {
        // verify required parameter "manifestId" is set
        if (params["manifestId"] == null) {
            throw new Error("Missing required parameter manifestId when calling manifestAdminGetSuspend");
        }
        // verify required parameter "isSuspended" is set
        if (params["isSuspended"] == null) {
            throw new Error("Missing required parameter isSuspended when calling manifestAdminGetSuspend");
        }
        // verify required parameter "reason" is set
        if (params["reason"] == null) {
            throw new Error("Missing required parameter reason when calling manifestAdminGetSuspend");
        }
        const baseUrl = `/api/admin/manifests/{manifestId}/suspend`
            .replace(`{${"manifestId"}}`, `${ params["manifestId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "isSuspended": params["isSuspended"],
            "reason": params["reason"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ManifestAdminApi - functional programming interface
 */
export const ManifestAdminApiFp = {
    /** 
     * @param userId 
     * @param shipped 
     * @param skip 
     * @param take 
     */
    manifestAdminGet(params: { "userId": string; "shipped": boolean; "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PgCloudCellarRecord>> {
        const fetchArgs = ManifestAdminApiFetchParamCreator.manifestAdminGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    manifestAdminGetClaimGiftManifest(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ManifestAdminApiFetchParamCreator.manifestAdminGetClaimGiftManifest(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param manifestId 
     * @param isSuspended 
     * @param reason 
     */
    manifestAdminGetSuspend(params: { "manifestId": string; "isSuspended": boolean; "reason": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2ManifestEntity> {
        const fetchArgs = ManifestAdminApiFetchParamCreator.manifestAdminGetSuspend(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ManifestAdminApi - object-oriented interface
 */
export class ManifestAdminApi extends BaseAPI {
    /** 
     * @param userId 
     * @param shipped 
     * @param skip 
     * @param take 
     */
    manifestAdminGet(params: {  "userId": string; "shipped": boolean; "skip"?: number; "take"?: number; }, options?: any) {
        return ManifestAdminApiFp.manifestAdminGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    manifestAdminGetClaimGiftManifest(params: {  "id": string; }, options?: any) {
        return ManifestAdminApiFp.manifestAdminGetClaimGiftManifest(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param manifestId 
     * @param isSuspended 
     * @param reason 
     */
    manifestAdminGetSuspend(params: {  "manifestId": string; "isSuspended": boolean; "reason": string; }, options?: any) {
        return ManifestAdminApiFp.manifestAdminGetSuspend(params, options)(this.fetch, this.basePath);
    }
};

/**
 * ManifestAdminApi - factory interface
 */
export const ManifestAdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userId 
         * @param shipped 
         * @param skip 
         * @param take 
         */
        manifestAdminGet(params: {  "userId": string; "shipped": boolean; "skip"?: number; "take"?: number; }, options?: any) {
            return ManifestAdminApiFp.manifestAdminGet(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        manifestAdminGetClaimGiftManifest(params: {  "id": string; }, options?: any) {
            return ManifestAdminApiFp.manifestAdminGetClaimGiftManifest(params, options)(fetch, basePath);
        },
        /** 
         * @param manifestId 
         * @param isSuspended 
         * @param reason 
         */
        manifestAdminGetSuspend(params: {  "manifestId": string; "isSuspended": boolean; "reason": string; }, options?: any) {
            return ManifestAdminApiFp.manifestAdminGetSuspend(params, options)(fetch, basePath);
        },
    };
};


/**
 * OfferApi - fetch parameter creator
 */
export const OfferApiFetchParamCreator = {
    /** 
     * @param offerSef 
     */
    offerGetDetail(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetDetail");
        }
        const baseUrl = `/api/v2/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerGetLiveFeed(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetLiveFeed");
        }
        const baseUrl = `/api/v2/offer/{offerSef}/feed`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param zipCode 
     * @param qty 
     */
    offerGetOfferTax(params: {  "offerSef": string; "zipCode": number; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetOfferTax");
        }
        // verify required parameter "zipCode" is set
        if (params["zipCode"] == null) {
            throw new Error("Missing required parameter zipCode when calling offerGetOfferTax");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling offerGetOfferTax");
        }
        const baseUrl = `/api/v2/offer/{offerSef}/tax/{zipCode}/{qty}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"zipCode"}}`, `${ params["zipCode"] }`)
            .replace(`{${"qty"}}`, `${ params["qty"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param promoCode 
     * @param qty 
     */
    offerGetV2OfferIdCheckPromo(params: {  "offerSef": string; "promoCode": string; "qty": number; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerGetV2OfferIdCheckPromo");
        }
        // verify required parameter "promoCode" is set
        if (params["promoCode"] == null) {
            throw new Error("Missing required parameter promoCode when calling offerGetV2OfferIdCheckPromo");
        }
        // verify required parameter "qty" is set
        if (params["qty"] == null) {
            throw new Error("Missing required parameter qty when calling offerGetV2OfferIdCheckPromo");
        }
        const baseUrl = `/api/v2/offer/{offerSef}/checkPromo`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "promoCode": params["promoCode"],
            "qty": params["qty"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    offerHandleListAppellation(options?: any): FetchArgs {
        const baseUrl = `/api/v2/appellation`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    offerHandleListRegion(options?: any): FetchArgs {
        const baseUrl = `/api/v2/region`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpDeleteAdminV2OfferItemGroupById");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpDeleteAdminV2OfferItemGroupById");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search 
     */
    offerHttpGetAdminV2Offer(params: {  "search": string; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling offerHttpGetAdminV2Offer");
        }
        const baseUrl = `/api/v2/admin/offer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpGetAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferItemGroupById");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpGetAdminV2OfferItemGroupById");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferManifest");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/manifest`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferOverview");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/overview`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSef");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSkuList");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpGetAdminV2OfferSkuSales");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku/sales`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param entity 
     */
    offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; }, options?: any): FetchArgs {
        // verify required parameter "entity" is set
        if (params["entity"] == null) {
            throw new Error("Missing required parameter entity when calling offerHttpPostAdminV2Offer");
        }
        const baseUrl = `/api/v2/admin/offer`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["entity"]) {
            fetchOptions.body = JSON.stringify(params["entity"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param itemGroupToAdd 
     */
    offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPostAdminV2OfferSkuList");
        }
        // verify required parameter "itemGroupToAdd" is set
        if (params["itemGroupToAdd"] == null) {
            throw new Error("Missing required parameter itemGroupToAdd when calling offerHttpPostAdminV2OfferSkuList");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/sku`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemGroupToAdd"]) {
            fetchOptions.body = JSON.stringify(params["itemGroupToAdd"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     */
    offerHttpPutAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPutAdminV2OfferItemGroupById");
        }
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling offerHttpPutAdminV2OfferItemGroupById");
        }
        // verify required parameter "itemGroup" is set
        if (params["itemGroup"] == null) {
            throw new Error("Missing required parameter itemGroup when calling offerHttpPutAdminV2OfferItemGroupById");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}/itemgroup/{id}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`)
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["itemGroup"]) {
            fetchOptions.body = JSON.stringify(params["itemGroup"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     * @param model 
     */
    offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerHttpPutAdminV2OfferSef");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling offerHttpPutAdminV2OfferSef");
        }
        const baseUrl = `/api/v2/admin/offer/{offerSef}`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/offer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "filter": params["filter"],
            "skip": params["skip"],
            "take": params["take"],
            "forcePopulate": params["forcePopulate"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OfferApi - functional programming interface
 */
export const OfferApiFp = {
    /** 
     * @param offerSef 
     */
    offerGetDetail(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferDetailModel> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerGetLiveFeed(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LiveFeedItem>> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetLiveFeed(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param zipCode 
     * @param qty 
     */
    offerGetOfferTax(params: { "offerSef": string; "zipCode": number; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaxInfo> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetOfferTax(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param promoCode 
     * @param qty 
     */
    offerGetV2OfferIdCheckPromo(params: { "offerSef": string; "promoCode": string; "qty": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutPromoCodeModel> {
        const fetchArgs = OfferApiFetchParamCreator.offerGetV2OfferIdCheckPromo(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    offerHandleListAppellation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHandleListAppellation(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    offerHandleListRegion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHandleListRegion(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: { "offerSef": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpDeleteAdminV2OfferItemGroupById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search 
     */
    offerHttpGetAdminV2Offer(params: { "search": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2Entity>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2Offer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpGetAdminV2OfferItemGroupById(params: { "offerSef": string; "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferItemGroupById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferManifest(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2AdminManifest>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferManifest(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminOfferOverviewModel> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferOverview(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSef(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhItemGroupEntity>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuSales(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuSale>> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpGetAdminV2OfferSkuSales(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param entity 
     */
    offerHttpPostAdminV2Offer(params: { "entity": OfferV2Entity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPostAdminV2Offer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param itemGroupToAdd 
     */
    offerHttpPostAdminV2OfferSkuList(params: { "offerSef": string; "itemGroupToAdd": NhItemGroupEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPostAdminV2OfferSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     */
    offerHttpPutAdminV2OfferItemGroupById(params: { "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhItemGroupEntity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPutAdminV2OfferItemGroupById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     * @param model 
     */
    offerHttpPutAdminV2OfferSef(params: { "offerSef": string; "model": OfferV2Entity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferApiFetchParamCreator.offerHttpPutAdminV2OfferSef(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: { "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OfferV2Entity>> {
        const fetchArgs = OfferApiFetchParamCreator.offerOfferListHandler(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OfferApi - object-oriented interface
 */
export class OfferApi extends BaseAPI {
    /** 
     * @param offerSef 
     */
    offerGetDetail(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerGetDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerGetLiveFeed(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerGetLiveFeed(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param zipCode 
     * @param qty 
     */
    offerGetOfferTax(params: {  "offerSef": string; "zipCode": number; "qty": number; }, options?: any) {
        return OfferApiFp.offerGetOfferTax(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param promoCode 
     * @param qty 
     */
    offerGetV2OfferIdCheckPromo(params: {  "offerSef": string; "promoCode": string; "qty": number; }, options?: any) {
        return OfferApiFp.offerGetV2OfferIdCheckPromo(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    offerHandleListAppellation(options?: any) {
        return OfferApiFp.offerHandleListAppellation(options)(this.fetch, this.basePath);
    }
    /** 
     */
    offerHandleListRegion(options?: any) {
        return OfferApiFp.offerHandleListRegion(options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any) {
        return OfferApiFp.offerHttpDeleteAdminV2OfferItemGroupById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param search 
     */
    offerHttpGetAdminV2Offer(params: {  "search": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2Offer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param id 
     */
    offerHttpGetAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferItemGroupById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferManifest(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferOverview(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSef(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSkuList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; }, options?: any) {
        return OfferApiFp.offerHttpGetAdminV2OfferSkuSales(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param entity 
     */
    offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; }, options?: any) {
        return OfferApiFp.offerHttpPostAdminV2Offer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param itemGroupToAdd 
     */
    offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; }, options?: any) {
        return OfferApiFp.offerHttpPostAdminV2OfferSkuList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param id 
     * @param itemGroup 
     */
    offerHttpPutAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; }, options?: any) {
        return OfferApiFp.offerHttpPutAdminV2OfferItemGroupById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     * @param model 
     */
    offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; }, options?: any) {
        return OfferApiFp.offerHttpPutAdminV2OfferSef(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param filter 
     * @param skip 
     * @param take 
     * @param forcePopulate 
     * @param search 
     */
    offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any) {
        return OfferApiFp.offerOfferListHandler(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OfferApi - factory interface
 */
export const OfferApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param offerSef 
         */
        offerGetDetail(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerGetDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerGetLiveFeed(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerGetLiveFeed(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param zipCode 
         * @param qty 
         */
        offerGetOfferTax(params: {  "offerSef": string; "zipCode": number; "qty": number; }, options?: any) {
            return OfferApiFp.offerGetOfferTax(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param promoCode 
         * @param qty 
         */
        offerGetV2OfferIdCheckPromo(params: {  "offerSef": string; "promoCode": string; "qty": number; }, options?: any) {
            return OfferApiFp.offerGetV2OfferIdCheckPromo(params, options)(fetch, basePath);
        },
        /** 
         */
        offerHandleListAppellation(options?: any) {
            return OfferApiFp.offerHandleListAppellation(options)(fetch, basePath);
        },
        /** 
         */
        offerHandleListRegion(options?: any) {
            return OfferApiFp.offerHandleListRegion(options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param id 
         */
        offerHttpDeleteAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any) {
            return OfferApiFp.offerHttpDeleteAdminV2OfferItemGroupById(params, options)(fetch, basePath);
        },
        /** 
         * @param search 
         */
        offerHttpGetAdminV2Offer(params: {  "search": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2Offer(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param id 
         */
        offerHttpGetAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferItemGroupById(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferManifest(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferManifest(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferOverview(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferOverview(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferSef(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSef(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferSkuList(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSkuList(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerHttpGetAdminV2OfferSkuSales(params: {  "offerSef": string; }, options?: any) {
            return OfferApiFp.offerHttpGetAdminV2OfferSkuSales(params, options)(fetch, basePath);
        },
        /** 
         * @param entity 
         */
        offerHttpPostAdminV2Offer(params: {  "entity": OfferV2Entity; }, options?: any) {
            return OfferApiFp.offerHttpPostAdminV2Offer(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param itemGroupToAdd 
         */
        offerHttpPostAdminV2OfferSkuList(params: {  "offerSef": string; "itemGroupToAdd": NhItemGroupEntity; }, options?: any) {
            return OfferApiFp.offerHttpPostAdminV2OfferSkuList(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param id 
         * @param itemGroup 
         */
        offerHttpPutAdminV2OfferItemGroupById(params: {  "offerSef": string; "id": string; "itemGroup": NhItemGroupEntity; }, options?: any) {
            return OfferApiFp.offerHttpPutAdminV2OfferItemGroupById(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         * @param model 
         */
        offerHttpPutAdminV2OfferSef(params: {  "offerSef": string; "model": OfferV2Entity; }, options?: any) {
            return OfferApiFp.offerHttpPutAdminV2OfferSef(params, options)(fetch, basePath);
        },
        /** 
         * @param filter 
         * @param skip 
         * @param take 
         * @param forcePopulate 
         * @param search 
         */
        offerOfferListHandler(params: {  "filter"?: boolean; "skip"?: number; "take"?: number; "forcePopulate"?: boolean; "search"?: string; }, options?: any) {
            return OfferApiFp.offerOfferListHandler(params, options)(fetch, basePath);
        },
    };
};


/**
 * OfferDetailApi - fetch parameter creator
 */
export const OfferDetailApiFetchParamCreator = {
    /** 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetLiveFeedDetail");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/feed`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetOfferBottles");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/bottles`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling offerDetailGetOfferDetailBasic");
        }
        const baseUrl = `/api/offer/detail/{offerSef}/basic`
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any): FetchArgs {
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling offerDetailPostOfferUploadImage");
        }
        const baseUrl = `/api/offer/detail/uploadImage`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    offerDetailSitemapIndex(options?: any): FetchArgs {
        const baseUrl = `/api/offer/sitemapIndex`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OfferDetailApi - functional programming interface
 */
export const OfferDetailApiFp = {
    /** 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LiveFeedItem>> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetLiveFeedDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhItemGroupViewEntity>> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetOfferBottles(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: { "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OfferV2Entity> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailGetOfferDetailBasic(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: { "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailPostOfferUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    offerDetailSitemapIndex(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OfferDetailApiFetchParamCreator.offerDetailSitemapIndex(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OfferDetailApi - object-oriented interface
 */
export class OfferDetailApi extends BaseAPI {
    /** 
     * @param offerSef 
     */
    offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetLiveFeedDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetOfferBottles(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param offerSef 
     */
    offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any) {
        return OfferDetailApiFp.offerDetailGetOfferDetailBasic(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param file 
     */
    offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any) {
        return OfferDetailApiFp.offerDetailPostOfferUploadImage(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    offerDetailSitemapIndex(options?: any) {
        return OfferDetailApiFp.offerDetailSitemapIndex(options)(this.fetch, this.basePath);
    }
};

/**
 * OfferDetailApi - factory interface
 */
export const OfferDetailApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param offerSef 
         */
        offerDetailGetLiveFeedDetail(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetLiveFeedDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerDetailGetOfferBottles(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetOfferBottles(params, options)(fetch, basePath);
        },
        /** 
         * @param offerSef 
         */
        offerDetailGetOfferDetailBasic(params: {  "offerSef": string; }, options?: any) {
            return OfferDetailApiFp.offerDetailGetOfferDetailBasic(params, options)(fetch, basePath);
        },
        /** 
         * @param file 
         */
        offerDetailPostOfferUploadImage(params: {  "file": any; }, options?: any) {
            return OfferDetailApiFp.offerDetailPostOfferUploadImage(params, options)(fetch, basePath);
        },
        /** 
         */
        offerDetailSitemapIndex(options?: any) {
            return OfferDetailApiFp.offerDetailSitemapIndex(options)(fetch, basePath);
        },
    };
};


/**
 * OrderStatusApi - fetch parameter creator
 */
export const OrderStatusApiFetchParamCreator = {
    /** 
     * @param userId 
     */
    orderStatusGet(params: {  "userId": string; }, options?: any): FetchArgs {
        // verify required parameter "userId" is set
        if (params["userId"] == null) {
            throw new Error("Missing required parameter userId when calling orderStatusGet");
        }
        const baseUrl = `/api/user/{userId}/referral`
            .replace(`{${"userId"}}`, `${ params["userId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param orderId 
     */
    orderStatusGetOrder(params: {  "userGuid": string; "orderId": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling orderStatusGetOrder");
        }
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling orderStatusGetOrder");
        }
        const baseUrl = `/api/user/{userGuid}/order/{orderId}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    orderStatusGetOrders(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling orderStatusGetOrders");
        }
        const baseUrl = `/api/user/{userGuid}/order`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * OrderStatusApi - functional programming interface
 */
export const OrderStatusApiFp = {
    /** 
     * @param userId 
     */
    orderStatusGet(params: { "userId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = OrderStatusApiFetchParamCreator.orderStatusGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param orderId 
     */
    orderStatusGetOrder(params: { "userGuid": string; "orderId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrderModelExtended> {
        const fetchArgs = OrderStatusApiFetchParamCreator.orderStatusGetOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    orderStatusGetOrders(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersOverviewModel> {
        const fetchArgs = OrderStatusApiFetchParamCreator.orderStatusGetOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * OrderStatusApi - object-oriented interface
 */
export class OrderStatusApi extends BaseAPI {
    /** 
     * @param userId 
     */
    orderStatusGet(params: {  "userId": string; }, options?: any) {
        return OrderStatusApiFp.orderStatusGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param orderId 
     */
    orderStatusGetOrder(params: {  "userGuid": string; "orderId": string; }, options?: any) {
        return OrderStatusApiFp.orderStatusGetOrder(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    orderStatusGetOrders(params: {  "userGuid": string; }, options?: any) {
        return OrderStatusApiFp.orderStatusGetOrders(params, options)(this.fetch, this.basePath);
    }
};

/**
 * OrderStatusApi - factory interface
 */
export const OrderStatusApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userId 
         */
        orderStatusGet(params: {  "userId": string; }, options?: any) {
            return OrderStatusApiFp.orderStatusGet(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param orderId 
         */
        orderStatusGetOrder(params: {  "userGuid": string; "orderId": string; }, options?: any) {
            return OrderStatusApiFp.orderStatusGetOrder(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        orderStatusGetOrders(params: {  "userGuid": string; }, options?: any) {
            return OrderStatusApiFp.orderStatusGetOrders(params, options)(fetch, basePath);
        },
    };
};


/**
 * PaymentApi - fetch parameter creator
 */
export const PaymentApiFetchParamCreator = {
    /** 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentGetAddressAndPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-address-and-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user&#39;s profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentPostAddressAndPayment");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling paymentPostAddressAndPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-address-and-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Delete an authenticated user&#39;s payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionDeletePayment");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionDeletePayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPaymentById");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionGetPaymentById");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPayments");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionGetPaymentsList");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Creates a new payment entity in the authenticated user&#39;s profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionPostPayment");
        }
        // verify required parameter "ccinfo" is set
        if (params["ccinfo"] == null) {
            throw new Error("Missing required parameter ccinfo when calling paymentSessionPostPayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["ccinfo"]) {
            fetchOptions.body = JSON.stringify(params["ccinfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Update a user&#39;s payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling paymentSessionUpdatePayment");
        }
        // verify required parameter "paymentProfileId" is set
        if (params["paymentProfileId"] == null) {
            throw new Error("Missing required parameter paymentProfileId when calling paymentSessionUpdatePayment");
        }
        // verify required parameter "newInfo" is set
        if (params["newInfo"] == null) {
            throw new Error("Missing required parameter newInfo when calling paymentSessionUpdatePayment");
        }
        const baseUrl = `/api/session/{sessionId}/user-payment/{paymentProfileId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"paymentProfileId"}}`, `${ params["paymentProfileId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newInfo"]) {
            fetchOptions.body = JSON.stringify(params["newInfo"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PaymentApi - functional programming interface
 */
export const PaymentApiFp = {
    /** 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PaymentWithAddressModel>> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentGetAddressAndPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user&#39;s profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: { "sessionId": string; "model": PaymentWithAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PaymentWithAddressModel> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentPostAddressAndPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Delete an authenticated user&#39;s payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: { "sessionId": string; "paymentProfileId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionDeletePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: { "sessionId": string; "paymentProfileId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPaymentById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: ApiBillingModelWithCardNumber; }> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPayments(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApiBillingModelWithCardNumber>> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionGetPaymentsList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Creates a new payment entity in the authenticated user&#39;s profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: { "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionPostPayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Update a user&#39;s payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: { "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiBillingModelWithAuthnet> {
        const fetchArgs = PaymentApiFetchParamCreator.paymentSessionUpdatePayment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PaymentApi - object-oriented interface
 */
export class PaymentApi extends BaseAPI {
    /** 
     * @param sessionId 
     */
    paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentGetAddressAndPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user&#39;s profile.
     * @param sessionId Session identifier.
     * @param model Specify address and payment to add.
     */
    paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any) {
        return PaymentApiFp.paymentPostAddressAndPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Delete an authenticated user&#39;s payment profile. Also removes the profile from CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionDeletePayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets a detailed payment profile for the authenticated user.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     */
    paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPaymentById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPayments(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets a list of payment profiles for the authenticated user.
     * @param sessionId The session token of the logged-in user.
     */
    paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any) {
        return PaymentApiFp.paymentSessionGetPaymentsList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Creates a new payment entity in the authenticated user&#39;s profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
     * @param sessionId Session identifier.
     * @param ccinfo Ccinfo.
     */
    paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any) {
        return PaymentApiFp.paymentSessionPostPayment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Update a user&#39;s payment profile. Also updates CIM.
     * @param sessionId Session identifier.
     * @param paymentProfileId Payment profile identifier.
     * @param newInfo New payment info.
     */
    paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any) {
        return PaymentApiFp.paymentSessionUpdatePayment(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PaymentApi - factory interface
 */
export const PaymentApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param sessionId 
         */
        paymentGetAddressAndPayment(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentGetAddressAndPayment(params, options)(fetch, basePath);
        },
        /** 
         * Convenience method to create both an address and payment entry. Will reuse existing address if a match already  exists in the user&#39;s profile.
         * @param sessionId Session identifier.
         * @param model Specify address and payment to add.
         */
        paymentPostAddressAndPayment(params: {  "sessionId": string; "model": PaymentWithAddressModel; }, options?: any) {
            return PaymentApiFp.paymentPostAddressAndPayment(params, options)(fetch, basePath);
        },
        /** 
         * Delete an authenticated user&#39;s payment profile. Also removes the profile from CIM.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         */
        paymentSessionDeletePayment(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionDeletePayment(params, options)(fetch, basePath);
        },
        /** 
         * Gets a detailed payment profile for the authenticated user.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         */
        paymentSessionGetPaymentById(params: {  "sessionId": string; "paymentProfileId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPaymentById(params, options)(fetch, basePath);
        },
        /** 
         * Gets a list of payment profiles for the authenticated user.
         * @param sessionId The session token of the logged-in user.
         */
        paymentSessionGetPayments(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPayments(params, options)(fetch, basePath);
        },
        /** 
         * Gets a list of payment profiles for the authenticated user.
         * @param sessionId The session token of the logged-in user.
         */
        paymentSessionGetPaymentsList(params: {  "sessionId": string; }, options?: any) {
            return PaymentApiFp.paymentSessionGetPaymentsList(params, options)(fetch, basePath);
        },
        /** 
         * Creates a new payment entity in the authenticated user&#39;s profile. Also creates the payment entity in CIM. The  Address entity should have already been created.
         * @param sessionId Session identifier.
         * @param ccinfo Ccinfo.
         */
        paymentSessionPostPayment(params: {  "sessionId": string; "ccinfo": ApiBillingModelWithAuthnet; }, options?: any) {
            return PaymentApiFp.paymentSessionPostPayment(params, options)(fetch, basePath);
        },
        /** 
         * Update a user&#39;s payment profile. Also updates CIM.
         * @param sessionId Session identifier.
         * @param paymentProfileId Payment profile identifier.
         * @param newInfo New payment info.
         */
        paymentSessionUpdatePayment(params: {  "sessionId": string; "paymentProfileId": string; "newInfo": ApiBillingModelWithAuthnet; }, options?: any) {
            return PaymentApiFp.paymentSessionUpdatePayment(params, options)(fetch, basePath);
        },
    };
};


/**
 * PromoGroupApi - fetch parameter creator
 */
export const PromoGroupApiFetchParamCreator = {
    /** 
     * GET /api/promoGroup/
     */
    promoGroupGet(options?: any): FetchArgs {
        const baseUrl = `/api/promogroup`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * GET /api/promoGroup/##
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling promoGroupGet_1");
        }
        const baseUrl = `/api/promogroup/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PromoGroupApi - functional programming interface
 */
export const PromoGroupApiFp = {
    /** 
     * GET /api/promoGroup/
     */
    promoGroupGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = PromoGroupApiFetchParamCreator.promoGroupGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * GET /api/promoGroup/##
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhPromoCodeModel>> {
        const fetchArgs = PromoGroupApiFetchParamCreator.promoGroupGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PromoGroupApi - object-oriented interface
 */
export class PromoGroupApi extends BaseAPI {
    /** 
     * GET /api/promoGroup/
     */
    promoGroupGet(options?: any) {
        return PromoGroupApiFp.promoGroupGet(options)(this.fetch, this.basePath);
    }
    /** 
     * GET /api/promoGroup/##
     * @param id id of the promo group to enumerate promo codes
     */
    promoGroupGet_1(params: {  "id": string; }, options?: any) {
        return PromoGroupApiFp.promoGroupGet_1(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PromoGroupApi - factory interface
 */
export const PromoGroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * GET /api/promoGroup/
         */
        promoGroupGet(options?: any) {
            return PromoGroupApiFp.promoGroupGet(options)(fetch, basePath);
        },
        /** 
         * GET /api/promoGroup/##
         * @param id id of the promo group to enumerate promo codes
         */
        promoGroupGet_1(params: {  "id": string; }, options?: any) {
            return PromoGroupApiFp.promoGroupGet_1(params, options)(fetch, basePath);
        },
    };
};


/**
 * PurchaseOrderApi - fetch parameter creator
 */
export const PurchaseOrderApiFetchParamCreator = {
    /** 
     * @param id 
     */
    purchaseOrderGetCplPurchaseOrderById(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling purchaseOrderGetCplPurchaseOrderById");
        }
        const baseUrl = `/api/v2/admin/po/cpl/id/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    purchaseOrderGetPurchaseOrderId(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling purchaseOrderGetPurchaseOrderId");
        }
        const baseUrl = `/api/v2/admin/po/id/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    purchaseOrderGetPurchaseOrderList(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/po/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/po`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling purchaseOrderGetPurchaseOrdersForSku");
        }
        const baseUrl = `/api/v2/admin/po/sku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: {  "model": PurchaseOrderModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling purchaseOrderPostPurchaseOrder");
        }
        const baseUrl = `/api/v2/admin/po`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PurchaseOrderApi - functional programming interface
 */
export const PurchaseOrderApiFp = {
    /** 
     * @param id 
     */
    purchaseOrderGetCplPurchaseOrderById(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PurchaseOrder> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetCplPurchaseOrderById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    purchaseOrderGetPurchaseOrderId(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PurchaseOrderModel> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrderId(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    purchaseOrderGetPurchaseOrderList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrderList(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: { "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PurchaseOrderModel>> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<PurchaseOrderModel>> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderGetPurchaseOrdersForSku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: { "model": PurchaseOrderModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PurchaseOrderModel> {
        const fetchArgs = PurchaseOrderApiFetchParamCreator.purchaseOrderPostPurchaseOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PurchaseOrderApi - object-oriented interface
 */
export class PurchaseOrderApi extends BaseAPI {
    /** 
     * @param id 
     */
    purchaseOrderGetCplPurchaseOrderById(params: {  "id": string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetCplPurchaseOrderById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    purchaseOrderGetPurchaseOrderId(params: {  "id": string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderId(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    purchaseOrderGetPurchaseOrderList(options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderList(options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    purchaseOrderGetPurchaseOrders(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrders(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sku 
     */
    purchaseOrderGetPurchaseOrdersForSku(params: {  "sku": string; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrdersForSku(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    purchaseOrderPostPurchaseOrder(params: {  "model": PurchaseOrderModel; }, options?: any) {
        return PurchaseOrderApiFp.purchaseOrderPostPurchaseOrder(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PurchaseOrderApi - factory interface
 */
export const PurchaseOrderApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param id 
         */
        purchaseOrderGetCplPurchaseOrderById(params: {  "id": string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetCplPurchaseOrderById(params, options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        purchaseOrderGetPurchaseOrderId(params: {  "id": string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderId(params, options)(fetch, basePath);
        },
        /** 
         */
        purchaseOrderGetPurchaseOrderList(options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrderList(options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         * @param search 
         */
        purchaseOrderGetPurchaseOrders(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrders(params, options)(fetch, basePath);
        },
        /** 
         * @param sku 
         */
        purchaseOrderGetPurchaseOrdersForSku(params: {  "sku": string; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderGetPurchaseOrdersForSku(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        purchaseOrderPostPurchaseOrder(params: {  "model": PurchaseOrderModel; }, options?: any) {
            return PurchaseOrderApiFp.purchaseOrderPostPurchaseOrder(params, options)(fetch, basePath);
        },
    };
};


/**
 * SellerAdminApi - fetch parameter creator
 */
export const SellerAdminApiFetchParamCreator = {
    /** 
     * @param sellerId 
     */
    sellerAdminDelete(params: {  "sellerId": string; }, options?: any): FetchArgs {
        // verify required parameter "sellerId" is set
        if (params["sellerId"] == null) {
            throw new Error("Missing required parameter sellerId when calling sellerAdminDelete");
        }
        const baseUrl = `/api/v2/admin/seller/{sellerId}`
            .replace(`{${"sellerId"}}`, `${ params["sellerId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    sellerAdminGet(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/seller`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sellerId 
     */
    sellerAdminGet_1(params: {  "sellerId": string; }, options?: any): FetchArgs {
        // verify required parameter "sellerId" is set
        if (params["sellerId"] == null) {
            throw new Error("Missing required parameter sellerId when calling sellerAdminGet_1");
        }
        const baseUrl = `/api/v2/admin/seller/{sellerId}`
            .replace(`{${"sellerId"}}`, `${ params["sellerId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     */
    sellerAdminPost(params: {  "content": NhSellerEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling sellerAdminPost");
        }
        const baseUrl = `/api/v2/admin/seller`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     * @param sellerId 
     */
    sellerAdminPut(params: {  "content": NhSellerEntity; "sellerId": string; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling sellerAdminPut");
        }
        // verify required parameter "sellerId" is set
        if (params["sellerId"] == null) {
            throw new Error("Missing required parameter sellerId when calling sellerAdminPut");
        }
        const baseUrl = `/api/v2/admin/seller/{sellerId}`
            .replace(`{${"sellerId"}}`, `${ params["sellerId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SellerAdminApi - functional programming interface
 */
export const SellerAdminApiFp = {
    /** 
     * @param sellerId 
     */
    sellerAdminDelete(params: { "sellerId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SellerAdminApiFetchParamCreator.sellerAdminDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    sellerAdminGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhSellerEntity>> {
        const fetchArgs = SellerAdminApiFetchParamCreator.sellerAdminGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sellerId 
     */
    sellerAdminGet_1(params: { "sellerId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhSellerEntity>> {
        const fetchArgs = SellerAdminApiFetchParamCreator.sellerAdminGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     */
    sellerAdminPost(params: { "content": NhSellerEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhSellerEntity> {
        const fetchArgs = SellerAdminApiFetchParamCreator.sellerAdminPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     * @param sellerId 
     */
    sellerAdminPut(params: { "content": NhSellerEntity; "sellerId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhSellerEntity> {
        const fetchArgs = SellerAdminApiFetchParamCreator.sellerAdminPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SellerAdminApi - object-oriented interface
 */
export class SellerAdminApi extends BaseAPI {
    /** 
     * @param sellerId 
     */
    sellerAdminDelete(params: {  "sellerId": string; }, options?: any) {
        return SellerAdminApiFp.sellerAdminDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    sellerAdminGet(options?: any) {
        return SellerAdminApiFp.sellerAdminGet(options)(this.fetch, this.basePath);
    }
    /** 
     * @param sellerId 
     */
    sellerAdminGet_1(params: {  "sellerId": string; }, options?: any) {
        return SellerAdminApiFp.sellerAdminGet_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     */
    sellerAdminPost(params: {  "content": NhSellerEntity; }, options?: any) {
        return SellerAdminApiFp.sellerAdminPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     * @param sellerId 
     */
    sellerAdminPut(params: {  "content": NhSellerEntity; "sellerId": string; }, options?: any) {
        return SellerAdminApiFp.sellerAdminPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SellerAdminApi - factory interface
 */
export const SellerAdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param sellerId 
         */
        sellerAdminDelete(params: {  "sellerId": string; }, options?: any) {
            return SellerAdminApiFp.sellerAdminDelete(params, options)(fetch, basePath);
        },
        /** 
         */
        sellerAdminGet(options?: any) {
            return SellerAdminApiFp.sellerAdminGet(options)(fetch, basePath);
        },
        /** 
         * @param sellerId 
         */
        sellerAdminGet_1(params: {  "sellerId": string; }, options?: any) {
            return SellerAdminApiFp.sellerAdminGet_1(params, options)(fetch, basePath);
        },
        /** 
         * @param content 
         */
        sellerAdminPost(params: {  "content": NhSellerEntity; }, options?: any) {
            return SellerAdminApiFp.sellerAdminPost(params, options)(fetch, basePath);
        },
        /** 
         * @param content 
         * @param sellerId 
         */
        sellerAdminPut(params: {  "content": NhSellerEntity; "sellerId": string; }, options?: any) {
            return SellerAdminApiFp.sellerAdminPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * SessionApi - fetch parameter creator
 */
export const SessionApiFetchParamCreator = {
    /** 
     * Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionDelete(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionDelete");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Generates a new session id
     */
    sessionGet(options?: any): FetchArgs {
        const baseUrl = `/api/session`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionGiftList");
        }
        const baseUrl = `/api/session/{sessionId}/gc/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserCreditDetail(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserCreditDetail");
        }
        const baseUrl = `/api/session/{sessionId}/user-credit`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserDetail");
        }
        const baseUrl = `/api/session/{sessionId}/user-detail`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEmailPreferences");
        }
        const baseUrl = `/api/session/{sessionId}/user-email-preferences`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEnRouteBottleList");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserEnRouteBottleRedeem");
        }
        // verify required parameter "manifestGuid" is set
        if (params["manifestGuid"] == null) {
            throw new Error("Missing required parameter manifestGuid when calling sessionGetSessionUserEnRouteBottleRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "manifestGuid": params["manifestGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserOrders(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserOrders");
        }
        const baseUrl = `/api/session/{sessionId}/user-orders`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserReferral(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGetSessionUserReferral");
        }
        const baseUrl = `/api/session/{sessionId}/user-referral`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionGet_1");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleEnrollApplePush");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling sessionHandleEnrollApplePush");
        }
        const baseUrl = `/api/session/{sessionId}/apn`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelEntryPoint"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleGetApplePush");
        }
        const baseUrl = `/api/session/{sessionId}/apn`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "model.deviceToken": params["modelDeviceToken"],
            "model.entryPoint": params["modelEntryPoint"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionHandleSessionGiftRedeem");
        }
        // verify required parameter "claimCode" is set
        if (params["claimCode"] == null) {
            throw new Error("Missing required parameter claimCode when calling sessionHandleSessionGiftRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/gc/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "claimCode": params["claimCode"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPostSessionUploadImage");
        }
        // verify required parameter "file" is set
        if (params["file"] == null) {
            throw new Error("Missing required parameter file when calling sessionPostSessionUploadImage");
        }
        const baseUrl = `/api/session/{sessionId}/user-image`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPut");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling sessionPut");
        }
        const baseUrl = `/api/session/{sessionId}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPutSessionUserDetail");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling sessionPutSessionUserDetail");
        }
        const baseUrl = `/api/session/{sessionId}/user-detail`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling sessionPutSessionUserEnRouteBottleRedeem");
        }
        // verify required parameter "manifestGuid" is set
        if (params["manifestGuid"] == null) {
            throw new Error("Missing required parameter manifestGuid when calling sessionPutSessionUserEnRouteBottleRedeem");
        }
        const baseUrl = `/api/session/{sessionId}/enroute/redeem`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "manifestGuid": params["manifestGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SessionApi - functional programming interface
 */
export const SessionApiFp = {
    /** 
     * Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionDelete(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SessionApiFetchParamCreator.sessionDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Generates a new session id
     */
    sessionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SessionModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CodeWithOrder>> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionGiftList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserCreditDetail(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserCreditDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModelExtended> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhUserModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEmailPreferences(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeficitItem>> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEnRouteBottleList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: { "sessionId": string; "manifestGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PgCloudCellarRecord> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserEnRouteBottleRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserOrders(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrdersOverviewModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserOrders(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserReferral(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserReferralModel>> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGetSessionUserReferral(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SessionModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: { "sessionId": string; "model": ApplePushEnroll;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleEnrollApplePush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: { "sessionId": string; "modelDeviceToken"?: string; "modelEntryPoint"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleGetApplePush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: { "sessionId": string; "claimCode": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CheckoutPromoCodeModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionHandleSessionGiftRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: { "sessionId": string; "file": any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPostSessionUploadImage(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: { "sessionId": string; "data": SessionModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: { "sessionId": string; "model": UserModelExtended;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModelExtended> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPutSessionUserDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: { "sessionId": string; "manifestGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhCreditModel> {
        const fetchArgs = SessionApiFetchParamCreator.sessionPutSessionUserEnRouteBottleRedeem(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SessionApi - object-oriented interface
 */
export class SessionApi extends BaseAPI {
    /** 
     * Delete the session with the specified id, along with any other sessions which have expired.
     * @param sessionId Session identifier.
     */
    sessionDelete(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Generates a new session id
     */
    sessionGet(options?: any) {
        return SessionApiFp.sessionGet(options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionGiftList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserCreditDetail(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserCreditDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the session user detail.
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEmailPreferences(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
     * @param sessionId Session identifier.
     */
    sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEnRouteBottleList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserEnRouteBottleRedeem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserOrders(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserOrders(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    sessionGetSessionUserReferral(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGetSessionUserReferral(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Get the session with the specified id.
     * @param sessionId Session identifier.
     */
    sessionGet_1(params: {  "sessionId": string; }, options?: any) {
        return SessionApiFp.sessionGet_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param model 
     */
    sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any) {
        return SessionApiFp.sessionHandleEnrollApplePush(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param modelDeviceToken 
     * @param modelEntryPoint 
     */
    sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelEntryPoint"?: string; }, options?: any) {
        return SessionApiFp.sessionHandleGetApplePush(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param claimCode 
     */
    sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any) {
        return SessionApiFp.sessionHandleSessionGiftRedeem(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param file 
     */
    sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any) {
        return SessionApiFp.sessionPostSessionUploadImage(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Store the session with the specified id.
     * @param sessionId Session identifier.
     * @param data Data.
     */
    sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any) {
        return SessionApiFp.sessionPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Puts the session user detail.
     * @param sessionId Session identifier.
     * @param model Model.
     */
    sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any) {
        return SessionApiFp.sessionPutSessionUserDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param manifestGuid 
     */
    sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
        return SessionApiFp.sessionPutSessionUserEnRouteBottleRedeem(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SessionApi - factory interface
 */
export const SessionApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Delete the session with the specified id, along with any other sessions which have expired.
         * @param sessionId Session identifier.
         */
        sessionDelete(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionDelete(params, options)(fetch, basePath);
        },
        /** 
         * Generates a new session id
         */
        sessionGet(options?: any) {
            return SessionApiFp.sessionGet(options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        sessionGetSessionGiftList(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionGiftList(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        sessionGetSessionUserCreditDetail(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserCreditDetail(params, options)(fetch, basePath);
        },
        /** 
         * Gets the session user detail.
         * @param sessionId Session identifier.
         */
        sessionGetSessionUserDetail(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        sessionGetSessionUserEmailPreferences(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEmailPreferences(params, options)(fetch, basePath);
        },
        /** 
         * Gets the list of en-route bottles that are overdue for the current user. You can then redeem any of these  bottles for credit by calling Routes.SessionUserEnRouteBottleRedeem
         * @param sessionId Session identifier.
         */
        sessionGetSessionUserEnRouteBottleList(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEnRouteBottleList(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param manifestGuid 
         */
        sessionGetSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserEnRouteBottleRedeem(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        sessionGetSessionUserOrders(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserOrders(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        sessionGetSessionUserReferral(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGetSessionUserReferral(params, options)(fetch, basePath);
        },
        /** 
         * Get the session with the specified id.
         * @param sessionId Session identifier.
         */
        sessionGet_1(params: {  "sessionId": string; }, options?: any) {
            return SessionApiFp.sessionGet_1(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param model 
         */
        sessionHandleEnrollApplePush(params: {  "sessionId": string; "model": ApplePushEnroll; }, options?: any) {
            return SessionApiFp.sessionHandleEnrollApplePush(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param modelDeviceToken 
         * @param modelEntryPoint 
         */
        sessionHandleGetApplePush(params: {  "sessionId": string; "modelDeviceToken"?: string; "modelEntryPoint"?: string; }, options?: any) {
            return SessionApiFp.sessionHandleGetApplePush(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param claimCode 
         */
        sessionHandleSessionGiftRedeem(params: {  "sessionId": string; "claimCode": string; }, options?: any) {
            return SessionApiFp.sessionHandleSessionGiftRedeem(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param file 
         */
        sessionPostSessionUploadImage(params: {  "sessionId": string; "file": any; }, options?: any) {
            return SessionApiFp.sessionPostSessionUploadImage(params, options)(fetch, basePath);
        },
        /** 
         * Store the session with the specified id.
         * @param sessionId Session identifier.
         * @param data Data.
         */
        sessionPut(params: {  "sessionId": string; "data": SessionModel; }, options?: any) {
            return SessionApiFp.sessionPut(params, options)(fetch, basePath);
        },
        /** 
         * Puts the session user detail.
         * @param sessionId Session identifier.
         * @param model Model.
         */
        sessionPutSessionUserDetail(params: {  "sessionId": string; "model": UserModelExtended; }, options?: any) {
            return SessionApiFp.sessionPutSessionUserDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param manifestGuid 
         */
        sessionPutSessionUserEnRouteBottleRedeem(params: {  "sessionId": string; "manifestGuid": string; }, options?: any) {
            return SessionApiFp.sessionPutSessionUserEnRouteBottleRedeem(params, options)(fetch, basePath);
        },
    };
};


/**
 * ShipManagerApi - fetch parameter creator
 */
export const ShipManagerApiFetchParamCreator = {
    /** 
     * @param id 
     */
    shipManagerCancelShipment(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling shipManagerCancelShipment");
        }
        const baseUrl = `/api/admin/shipment/cancel/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; }, options?: any): FetchArgs {
        // verify required parameter "search" is set
        if (params["search"] == null) {
            throw new Error("Missing required parameter search when calling shipManagerGet");
        }
        // verify required parameter "skip" is set
        if (params["skip"] == null) {
            throw new Error("Missing required parameter skip when calling shipManagerGet");
        }
        const baseUrl = `/api/admin/shipment/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "search": params["search"],
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param page 
     */
    shipManagerGetCustomer(params: {  "page"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/cpl/customer`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "page": params["page"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling shipManagerPostManifestsByIdShip");
        }
        const baseUrl = `/api/admin/manifests/ship`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    shipManagerUpdateTracking(options?: any): FetchArgs {
        const baseUrl = `/api/admin/shipment/updateTracking`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * ShipManagerApi - functional programming interface
 */
export const ShipManagerApiFp = {
    /** 
     * @param id 
     */
    shipManagerCancelShipment(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerCancelShipment(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    shipManagerGet(params: { "search": string; "skip": number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ShippingModel>> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param page 
     */
    shipManagerGetCustomer(params: { "page"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NhAddressModel>> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerGetCustomer(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: { "model": ShippingModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ShippingModel> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerPostManifestsByIdShip(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    shipManagerUpdateTracking(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = ShipManagerApiFetchParamCreator.shipManagerUpdateTracking(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ShipManagerApi - object-oriented interface
 */
export class ShipManagerApi extends BaseAPI {
    /** 
     * @param id 
     */
    shipManagerCancelShipment(params: {  "id": string; }, options?: any) {
        return ShipManagerApiFp.shipManagerCancelShipment(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param search 
     * @param skip 
     * @param take 
     */
    shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; }, options?: any) {
        return ShipManagerApiFp.shipManagerGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param page 
     */
    shipManagerGetCustomer(params: {  "page"?: number; }, options?: any) {
        return ShipManagerApiFp.shipManagerGetCustomer(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any) {
        return ShipManagerApiFp.shipManagerPostManifestsByIdShip(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    shipManagerUpdateTracking(options?: any) {
        return ShipManagerApiFp.shipManagerUpdateTracking(options)(this.fetch, this.basePath);
    }
};

/**
 * ShipManagerApi - factory interface
 */
export const ShipManagerApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param id 
         */
        shipManagerCancelShipment(params: {  "id": string; }, options?: any) {
            return ShipManagerApiFp.shipManagerCancelShipment(params, options)(fetch, basePath);
        },
        /** 
         * @param search 
         * @param skip 
         * @param take 
         */
        shipManagerGet(params: {  "search": string; "skip": number; "take"?: number; }, options?: any) {
            return ShipManagerApiFp.shipManagerGet(params, options)(fetch, basePath);
        },
        /** 
         * @param page 
         */
        shipManagerGetCustomer(params: {  "page"?: number; }, options?: any) {
            return ShipManagerApiFp.shipManagerGetCustomer(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        shipManagerPostManifestsByIdShip(params: {  "model": ShippingModel; }, options?: any) {
            return ShipManagerApiFp.shipManagerPostManifestsByIdShip(params, options)(fetch, basePath);
        },
        /** 
         */
        shipManagerUpdateTracking(options?: any) {
            return ShipManagerApiFp.shipManagerUpdateTracking(options)(fetch, basePath);
        },
    };
};


/**
 * SkuApi - fetch parameter creator
 */
export const SkuApiFetchParamCreator = {
    /** 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: {  "sku": string; "skuId": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuDelete");
        }
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuDelete");
        }
        const baseUrl = `/api/v2/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "sku": params["sku"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     * @param updateSharepoint 
     * @param sort 
     * @param reverse 
     */
    skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "updateSharepoint"?: boolean; "sort"?: string; "reverse"?: boolean; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
            "updateSharepoint": params["updateSharepoint"],
            "sort": params["sort"],
            "reverse": params["reverse"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/deficit`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    skuGetSkuListFreeLocations(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/freeLocations`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sku 
     */
    skuGetSkuStats(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuGetSkuStats");
        }
        const baseUrl = `/api/v2/admin/sku/stats/forSku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    skuGetSkuStatsByVarietal(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/stats/byVarietal`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    skuListCplIds(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/cplid`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     */
    skuPost(params: {  "content": SkuViewEntity; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling skuPost");
        }
        const baseUrl = `/api/v2/admin/sku/create`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sku 
     */
    skuPushSkuToCpl(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling skuPushSkuToCpl");
        }
        const baseUrl = `/api/v2/admin/sku/push/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skuId 
     * @param content 
     */
    skuPut(params: {  "skuId": string; "content": SkuViewEntity; }, options?: any): FetchArgs {
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuPut");
        }
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling skuPut");
        }
        const baseUrl = `/api/v2/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     */
    skuRebuildSkuHistory(params: {  "skip"?: number; "take"?: number; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/rebuildSkuHistory`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skuId 
     */
    skuSkuDetail(params: {  "skuId": string; }, options?: any): FetchArgs {
        // verify required parameter "skuId" is set
        if (params["skuId"] == null) {
            throw new Error("Missing required parameter skuId when calling skuSkuDetail");
        }
        const baseUrl = `/api/v2/admin/sku/byId/{skuId}`
            .replace(`{${"skuId"}}`, `${ params["skuId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any): FetchArgs {
        // verify required parameter "itemDetailSef" is set
        if (params["itemDetailSef"] == null) {
            throw new Error("Missing required parameter itemDetailSef when calling skuSkuListByItemDetail");
        }
        const baseUrl = `/api/v2/sku/byItemDetail/{itemDetailSef}`
            .replace(`{${"itemDetailSef"}}`, `${ params["itemDetailSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    skuSkuSwapGet(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    skuSkuSwapPost(params: {  "model": SkuSwapModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling skuSkuSwapPost");
        }
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    skuSkuSwapPut(params: {  "model": SkuSwapModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling skuSkuSwapPut");
        }
        const baseUrl = `/api/v2/admin/sku/swap`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * SkuApi - functional programming interface
 */
export const SkuApiFp = {
    /** 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: { "sku": string; "skuId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SkuApiFetchParamCreator.skuDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     * @param updateSharepoint 
     * @param sort 
     * @param reverse 
     */
    skuGetSkuList(params: { "skip"?: number; "take"?: number; "search"?: string; "updateSharepoint"?: boolean; "sort"?: string; "reverse"?: boolean;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuViewEntity>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuList(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: { "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuViewEntity>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuListDeficit(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    skuGetSkuListFreeLocations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OverallPlan> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuListFreeLocations(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sku 
     */
    skuGetSkuStats(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurplusItemDateTime>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuStats(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    skuGetSkuStatsByVarietal(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SurplusItemString>> {
        const fetchArgs = SkuApiFetchParamCreator.skuGetSkuStatsByVarietal(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    skuListCplIds(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
        const fetchArgs = SkuApiFetchParamCreator.skuListCplIds(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     */
    skuPost(params: { "content": SkuViewEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuViewEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sku 
     */
    skuPushSkuToCpl(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SkuApiFetchParamCreator.skuPushSkuToCpl(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skuId 
     * @param content 
     */
    skuPut(params: { "skuId": string; "content": SkuViewEntity;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuViewEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     */
    skuRebuildSkuHistory(params: { "skip"?: number; "take"?: number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = SkuApiFetchParamCreator.skuRebuildSkuHistory(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skuId 
     */
    skuSkuDetail(params: { "skuId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuEntity> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: { "itemDetailSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkuEntity>> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuListByItemDetail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    skuSkuSwapGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    skuSkuSwapPost(params: { "model": SkuSwapModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    skuSkuSwapPut(params: { "model": SkuSwapModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SkuSwapModel> {
        const fetchArgs = SkuApiFetchParamCreator.skuSkuSwapPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * SkuApi - object-oriented interface
 */
export class SkuApi extends BaseAPI {
    /** 
     * @param sku 
     * @param skuId 
     */
    skuDelete(params: {  "sku": string; "skuId": string; }, options?: any) {
        return SkuApiFp.skuDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     * @param search 
     * @param updateSharepoint 
     * @param sort 
     * @param reverse 
     */
    skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "updateSharepoint"?: boolean; "sort"?: string; "reverse"?: boolean; }, options?: any) {
        return SkuApiFp.skuGetSkuList(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return SkuApiFp.skuGetSkuListDeficit(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    skuGetSkuListFreeLocations(options?: any) {
        return SkuApiFp.skuGetSkuListFreeLocations(options)(this.fetch, this.basePath);
    }
    /** 
     * @param sku 
     */
    skuGetSkuStats(params: {  "sku": string; }, options?: any) {
        return SkuApiFp.skuGetSkuStats(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    skuGetSkuStatsByVarietal(options?: any) {
        return SkuApiFp.skuGetSkuStatsByVarietal(options)(this.fetch, this.basePath);
    }
    /** 
     */
    skuListCplIds(options?: any) {
        return SkuApiFp.skuListCplIds(options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     */
    skuPost(params: {  "content": SkuViewEntity; }, options?: any) {
        return SkuApiFp.skuPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sku 
     */
    skuPushSkuToCpl(params: {  "sku": string; }, options?: any) {
        return SkuApiFp.skuPushSkuToCpl(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skuId 
     * @param content 
     */
    skuPut(params: {  "skuId": string; "content": SkuViewEntity; }, options?: any) {
        return SkuApiFp.skuPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     */
    skuRebuildSkuHistory(params: {  "skip"?: number; "take"?: number; }, options?: any) {
        return SkuApiFp.skuRebuildSkuHistory(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skuId 
     */
    skuSkuDetail(params: {  "skuId": string; }, options?: any) {
        return SkuApiFp.skuSkuDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param itemDetailSef 
     */
    skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any) {
        return SkuApiFp.skuSkuListByItemDetail(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    skuSkuSwapGet(options?: any) {
        return SkuApiFp.skuSkuSwapGet(options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    skuSkuSwapPost(params: {  "model": SkuSwapModel; }, options?: any) {
        return SkuApiFp.skuSkuSwapPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    skuSkuSwapPut(params: {  "model": SkuSwapModel; }, options?: any) {
        return SkuApiFp.skuSkuSwapPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * SkuApi - factory interface
 */
export const SkuApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param sku 
         * @param skuId 
         */
        skuDelete(params: {  "sku": string; "skuId": string; }, options?: any) {
            return SkuApiFp.skuDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         * @param search 
         * @param updateSharepoint 
         * @param sort 
         * @param reverse 
         */
        skuGetSkuList(params: {  "skip"?: number; "take"?: number; "search"?: string; "updateSharepoint"?: boolean; "sort"?: string; "reverse"?: boolean; }, options?: any) {
            return SkuApiFp.skuGetSkuList(params, options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         * @param search 
         */
        skuGetSkuListDeficit(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return SkuApiFp.skuGetSkuListDeficit(params, options)(fetch, basePath);
        },
        /** 
         */
        skuGetSkuListFreeLocations(options?: any) {
            return SkuApiFp.skuGetSkuListFreeLocations(options)(fetch, basePath);
        },
        /** 
         * @param sku 
         */
        skuGetSkuStats(params: {  "sku": string; }, options?: any) {
            return SkuApiFp.skuGetSkuStats(params, options)(fetch, basePath);
        },
        /** 
         */
        skuGetSkuStatsByVarietal(options?: any) {
            return SkuApiFp.skuGetSkuStatsByVarietal(options)(fetch, basePath);
        },
        /** 
         */
        skuListCplIds(options?: any) {
            return SkuApiFp.skuListCplIds(options)(fetch, basePath);
        },
        /** 
         * @param content 
         */
        skuPost(params: {  "content": SkuViewEntity; }, options?: any) {
            return SkuApiFp.skuPost(params, options)(fetch, basePath);
        },
        /** 
         * @param sku 
         */
        skuPushSkuToCpl(params: {  "sku": string; }, options?: any) {
            return SkuApiFp.skuPushSkuToCpl(params, options)(fetch, basePath);
        },
        /** 
         * @param skuId 
         * @param content 
         */
        skuPut(params: {  "skuId": string; "content": SkuViewEntity; }, options?: any) {
            return SkuApiFp.skuPut(params, options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         */
        skuRebuildSkuHistory(params: {  "skip"?: number; "take"?: number; }, options?: any) {
            return SkuApiFp.skuRebuildSkuHistory(params, options)(fetch, basePath);
        },
        /** 
         * @param skuId 
         */
        skuSkuDetail(params: {  "skuId": string; }, options?: any) {
            return SkuApiFp.skuSkuDetail(params, options)(fetch, basePath);
        },
        /** 
         * @param itemDetailSef 
         */
        skuSkuListByItemDetail(params: {  "itemDetailSef": string; }, options?: any) {
            return SkuApiFp.skuSkuListByItemDetail(params, options)(fetch, basePath);
        },
        /** 
         */
        skuSkuSwapGet(options?: any) {
            return SkuApiFp.skuSkuSwapGet(options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        skuSkuSwapPost(params: {  "model": SkuSwapModel; }, options?: any) {
            return SkuApiFp.skuSkuSwapPost(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        skuSkuSwapPut(params: {  "model": SkuSwapModel; }, options?: any) {
            return SkuApiFp.skuSkuSwapPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * TelegramBotApi - fetch parameter creator
 */
export const TelegramBotApiFetchParamCreator = {
    /** 
     * @param update 
     */
    telegramBotPost(params: {  "update": Update; }, options?: any): FetchArgs {
        // verify required parameter "update" is set
        if (params["update"] == null) {
            throw new Error("Missing required parameter update when calling telegramBotPost");
        }
        const baseUrl = `/api/telegram`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["update"]) {
            fetchOptions.body = JSON.stringify(params["update"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TelegramBotApi - functional programming interface
 */
export const TelegramBotApiFp = {
    /** 
     * @param update 
     */
    telegramBotPost(params: { "update": Update;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TelegramBotApiFetchParamCreator.telegramBotPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TelegramBotApi - object-oriented interface
 */
export class TelegramBotApi extends BaseAPI {
    /** 
     * @param update 
     */
    telegramBotPost(params: {  "update": Update; }, options?: any) {
        return TelegramBotApiFp.telegramBotPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TelegramBotApi - factory interface
 */
export const TelegramBotApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param update 
         */
        telegramBotPost(params: {  "update": Update; }, options?: any) {
            return TelegramBotApiFp.telegramBotPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * TimeSeriesApi - fetch parameter creator
 */
export const TimeSeriesApiFetchParamCreator = {
    /** 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any): FetchArgs {
        // verify required parameter "start" is set
        if (params["start"] == null) {
            throw new Error("Missing required parameter start when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "end" is set
        if (params["end"] == null) {
            throw new Error("Missing required parameter end when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "includeTestUsers" is set
        if (params["includeTestUsers"] == null) {
            throw new Error("Missing required parameter includeTestUsers when calling timeSeriesBeginGenerateSeries");
        }
        // verify required parameter "utm" is set
        if (params["utm"] == null) {
            throw new Error("Missing required parameter utm when calling timeSeriesBeginGenerateSeries");
        }
        const baseUrl = `/api/report/timeseries/build`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "start": params["start"],
            "end": params["end"],
            "includeTestUsers": params["includeTestUsers"],
            "utm": params["utm"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    timeSeriesGetList(options?: any): FetchArgs {
        const baseUrl = `/api/report/timeseries/list`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "entityGuid" is set
        if (params["entityGuid"] == null) {
            throw new Error("Missing required parameter entityGuid when calling timeSeriesGetSeries");
        }
        const baseUrl = `/api/report/timeseries/view/{entityGuid}`
            .replace(`{${"entityGuid"}}`, `${ params["entityGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "entityGuid" is set
        if (params["entityGuid"] == null) {
            throw new Error("Missing required parameter entityGuid when calling timeSeriesGetSeriesRecords");
        }
        const baseUrl = `/api/report/timeseries/view/{entityGuid}/records`
            .replace(`{${"entityGuid"}}`, `${ params["entityGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * TimeSeriesApi - functional programming interface
 */
export const TimeSeriesApiFp = {
    /** 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: { "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TimeSeriesReport> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesBeginGenerateSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    timeSeriesGetList(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetList(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: { "entityGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetSeries(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: { "entityGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = TimeSeriesApiFetchParamCreator.timeSeriesGetSeriesRecords(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * TimeSeriesApi - object-oriented interface
 */
export class TimeSeriesApi extends BaseAPI {
    /** 
     * @param start 
     * @param end 
     * @param includeTestUsers 
     * @param utm 
     */
    timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesBeginGenerateSeries(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    timeSeriesGetList(options?: any) {
        return TimeSeriesApiFp.timeSeriesGetList(options)(this.fetch, this.basePath);
    }
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesGetSeries(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param entityGuid 
     */
    timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any) {
        return TimeSeriesApiFp.timeSeriesGetSeriesRecords(params, options)(this.fetch, this.basePath);
    }
};

/**
 * TimeSeriesApi - factory interface
 */
export const TimeSeriesApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param start 
         * @param end 
         * @param includeTestUsers 
         * @param utm 
         */
        timeSeriesBeginGenerateSeries(params: {  "start": Date; "end": Date; "includeTestUsers": boolean; "utm": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesBeginGenerateSeries(params, options)(fetch, basePath);
        },
        /** 
         */
        timeSeriesGetList(options?: any) {
            return TimeSeriesApiFp.timeSeriesGetList(options)(fetch, basePath);
        },
        /** 
         * @param entityGuid 
         */
        timeSeriesGetSeries(params: {  "entityGuid": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesGetSeries(params, options)(fetch, basePath);
        },
        /** 
         * @param entityGuid 
         */
        timeSeriesGetSeriesRecords(params: {  "entityGuid": string; }, options?: any) {
            return TimeSeriesApiFp.timeSeriesGetSeriesRecords(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /** 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userCanClaimFreeLetter");
        }
        const baseUrl = `/api/session/{sessionId}/freeletter`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userChangePassword");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userChangePassword");
        }
        const baseUrl = `/api/session/{sessionId}/user-passwd`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     */
    userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordChangeModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userChangePasswordAdmin");
        }
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userChangePasswordAdmin");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/setPassword`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    userClaimFreeLetter(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling userClaimFreeLetter");
        }
        const baseUrl = `/api/session/{sessionId}/freeletter`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userHttpUserCaptureEmail");
        }
        const baseUrl = `/api/user/captureEmail`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: {  "input": PasswordResetModel; }, options?: any): FetchArgs {
        // verify required parameter "input" is set
        if (params["input"] == null) {
            throw new Error("Missing required parameter input when calling userResetPassword");
        }
        const baseUrl = `/api/resetpassword`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["input"]) {
            fetchOptions.body = JSON.stringify(params["input"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userSetEmailPreferences");
        }
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSetEmailPreferences");
        }
        const baseUrl = `/api/v2/user/{userGuid}/email`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userSignIn(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignIn");
        }
        const baseUrl = `/api/user/auth`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userSignIn3(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignIn3");
        }
        const baseUrl = `/api/v3/user/auth`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userSignup(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignup");
        }
        const baseUrl = `/api/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userSignup3(params: {  "model": UserAuthModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userSignup3");
        }
        const baseUrl = `/api/v3/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /** 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultBoolean> {
        const fetchArgs = UserApiFetchParamCreator.userCanClaimFreeLetter(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: { "sessionId": string; "input": PasswordChangeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPasswordChangeModel> {
        const fetchArgs = UserApiFetchParamCreator.userChangePassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     */
    userChangePasswordAdmin(params: { "userGuid": string; "input": PasswordChangeModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultPasswordChangeModel> {
        const fetchArgs = UserApiFetchParamCreator.userChangePasswordAdmin(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    userClaimFreeLetter(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userClaimFreeLetter(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userHttpUserCaptureEmail(params: { "model": EmailCapture;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailCapture> {
        const fetchArgs = UserApiFetchParamCreator.userHttpUserCaptureEmail(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: { "input": PasswordResetModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultString> {
        const fetchArgs = UserApiFetchParamCreator.userResetPassword(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: { "userGuid": string; "model": NhUserEmailPreference;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultNhUserEmailPreference> {
        const fetchArgs = UserApiFetchParamCreator.userSetEmailPreferences(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userSignIn(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignIn(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userSignIn3(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignIn3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userSignup(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignup(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userSignup3(params: { "model": UserAuthModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiResultUserAuthResultModel> {
        const fetchArgs = UserApiFetchParamCreator.userSignup3(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /** 
     * @param sessionId 
     */
    userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
        return UserApiFp.userCanClaimFreeLetter(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Change the password for the current user (based on sessionId)
     * @param sessionId 
     * @param input 
     */
    userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any) {
        return UserApiFp.userChangePassword(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Change the password for the given user (based on userGuid); restricted to Admin only.
     * @param userGuid 
     * @param input 
     */
    userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordChangeModel; }, options?: any) {
        return UserApiFp.userChangePasswordAdmin(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    userClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
        return UserApiFp.userClaimFreeLetter(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any) {
        return UserApiFp.userHttpUserCaptureEmail(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Initiate a password reset operation.
     * @param input 
     */
    userResetPassword(params: {  "input": PasswordResetModel; }, options?: any) {
        return UserApiFp.userResetPassword(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param model 
     */
    userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any) {
        return UserApiFp.userSetEmailPreferences(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userSignIn(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignIn(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userSignIn3(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignIn3(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userSignup(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignup(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userSignup3(params: {  "model": UserAuthModel; }, options?: any) {
        return UserApiFp.userSignup3(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param sessionId 
         */
        userCanClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
            return UserApiFp.userCanClaimFreeLetter(params, options)(fetch, basePath);
        },
        /** 
         * Change the password for the current user (based on sessionId)
         * @param sessionId 
         * @param input 
         */
        userChangePassword(params: {  "sessionId": string; "input": PasswordChangeModel; }, options?: any) {
            return UserApiFp.userChangePassword(params, options)(fetch, basePath);
        },
        /** 
         * Change the password for the given user (based on userGuid); restricted to Admin only.
         * @param userGuid 
         * @param input 
         */
        userChangePasswordAdmin(params: {  "userGuid": string; "input": PasswordChangeModel; }, options?: any) {
            return UserApiFp.userChangePasswordAdmin(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        userClaimFreeLetter(params: {  "sessionId": string; }, options?: any) {
            return UserApiFp.userClaimFreeLetter(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userHttpUserCaptureEmail(params: {  "model": EmailCapture; }, options?: any) {
            return UserApiFp.userHttpUserCaptureEmail(params, options)(fetch, basePath);
        },
        /** 
         * Initiate a password reset operation.
         * @param input 
         */
        userResetPassword(params: {  "input": PasswordResetModel; }, options?: any) {
            return UserApiFp.userResetPassword(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param model 
         */
        userSetEmailPreferences(params: {  "userGuid": string; "model": NhUserEmailPreference; }, options?: any) {
            return UserApiFp.userSetEmailPreferences(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userSignIn(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignIn(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userSignIn3(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignIn3(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userSignup(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignup(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userSignup3(params: {  "model": UserAuthModel; }, options?: any) {
            return UserApiFp.userSignup3(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserAdminApi - fetch parameter creator
 */
export const UserAdminApiFetchParamCreator = {
    /** 
     * @param userGuid 
     */
    userAdminAddressGet(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAddressGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/addresses`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressGuid 
     */
    userAdminAddressGetById(params: {  "addressGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "addressGuid" is set
        if (params["addressGuid"] == null) {
            throw new Error("Missing required parameter addressGuid when calling userAdminAddressGetById");
        }
        const baseUrl = `/api/admin/address/byGuid/{addressGuid}`
            .replace(`{${"addressGuid"}}`, `${ params["addressGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param addressGuid 
     * @param addressModel 
     */
    userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; }, options?: any): FetchArgs {
        // verify required parameter "addressGuid" is set
        if (params["addressGuid"] == null) {
            throw new Error("Missing required parameter addressGuid when calling userAdminAddressPutById");
        }
        // verify required parameter "addressModel" is set
        if (params["addressModel"] == null) {
            throw new Error("Missing required parameter addressModel when calling userAdminAddressPutById");
        }
        const baseUrl = `/api/admin/address/byGuid/{addressGuid}`
            .replace(`{${"addressGuid"}}`, `${ params["addressGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["addressModel"]) {
            fetchOptions.body = JSON.stringify(params["addressModel"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: {  "userGuid": string; "giveLetters"?: string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAdminGetWordGame");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/wordgame`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "giveLetters": params["giveLetters"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminAdminRevokeWordGame(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminAdminRevokeWordGame");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/wordgame`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param creditGuid 
     */
    userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditDelete");
        }
        // verify required parameter "creditGuid" is set
        if (params["creditGuid"] == null) {
            throw new Error("Missing required parameter creditGuid when calling userAdminCreditDelete");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits/{creditGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"creditGuid"}}`, `${ params["creditGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminCreditGet(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param newCredit 
     */
    userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditPost");
        }
        // verify required parameter "newCredit" is set
        if (params["newCredit"] == null) {
            throw new Error("Missing required parameter newCredit when calling userAdminCreditPost");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["newCredit"]) {
            fetchOptions.body = JSON.stringify(params["newCredit"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     */
    userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminCreditPut");
        }
        // verify required parameter "creditGuid" is set
        if (params["creditGuid"] == null) {
            throw new Error("Missing required parameter creditGuid when calling userAdminCreditPut");
        }
        // verify required parameter "credit" is set
        if (params["credit"] == null) {
            throw new Error("Missing required parameter credit when calling userAdminCreditPut");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/credits/{creditGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`)
            .replace(`{${"creditGuid"}}`, `${ params["creditGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credit"]) {
            fetchOptions.body = JSON.stringify(params["credit"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    userAdminGet(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/admin/user/list`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminGetById(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminGetById");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sku 
     */
    userAdminGetUsersbySku(params: {  "sku": string; }, options?: any): FetchArgs {
        // verify required parameter "sku" is set
        if (params["sku"] == null) {
            throw new Error("Missing required parameter sku when calling userAdminGetUsersbySku");
        }
        const baseUrl = `/api/admin/user/bySku/{sku}`
            .replace(`{${"sku"}}`, `${ params["sku"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHandleAdminUserTicket");
        }
        const baseUrl = `/api/admin/user/ticket`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHttpPostAdminUserPush");
        }
        const baseUrl = `/api/admin/user/push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     */
    userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminHttpPutAdminUserPush");
        }
        const baseUrl = `/api/admin/user/push`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param oldUserGuid 
     * @param newUserGuid 
     */
    userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "oldUserGuid" is set
        if (params["oldUserGuid"] == null) {
            throw new Error("Missing required parameter oldUserGuid when calling userAdminMergeUsers");
        }
        // verify required parameter "newUserGuid" is set
        if (params["newUserGuid"] == null) {
            throw new Error("Missing required parameter newUserGuid when calling userAdminMergeUsers");
        }
        const baseUrl = `/api/admin/user/merge/{oldUserGuid}/into/{newUserGuid}`
            .replace(`{${"oldUserGuid"}}`, `${ params["oldUserGuid"] }`)
            .replace(`{${"newUserGuid"}}`, `${ params["newUserGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminPaymentsGet");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/payments`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: {  "model": UserModelExtended; "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "model" is set
        if (params["model"] == null) {
            throw new Error("Missing required parameter model when calling userAdminPutById");
        }
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userAdminPutById");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["model"]) {
            fetchOptions.body = JSON.stringify(params["model"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserAdminApi - functional programming interface
 */
export const UserAdminApiFp = {
    /** 
     * @param userGuid 
     */
    userAdminAddressGet(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressGuid 
     */
    userAdminAddressGetById(params: { "addressGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressGetById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param addressGuid 
     * @param addressModel 
     */
    userAdminAddressPutById(params: { "addressGuid": string; "addressModel": NhAddressModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAddressPutById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: { "userGuid": string; "giveLetters"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAdminGetWordGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminAdminRevokeWordGame(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminAdminRevokeWordGame(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param creditGuid 
     */
    userAdminCreditDelete(params: { "userGuid": string; "creditGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminCreditGet(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param newCredit 
     */
    userAdminCreditPost(params: { "userGuid": string; "newCredit": NhCreditModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     */
    userAdminCreditPut(params: { "userGuid": string; "creditGuid": string; "credit": NhCreditModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhCreditModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminCreditPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    userAdminGet(params: { "skip"?: number; "take"?: number; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserModelExtended>> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminGetById(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModelExtended> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sku 
     */
    userAdminGetUsersbySku(params: { "sku": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminGetUsersbySku(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: { "model": SupportTicket;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SupportTicket> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHandleAdminUserTicket(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userAdminHttpPostAdminUserPush(params: { "model": AdminUserPushModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminUserPushModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHttpPostAdminUserPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     */
    userAdminHttpPutAdminUserPush(params: { "model": AdminUserPushModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AdminUserPushModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminHttpPutAdminUserPush(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param oldUserGuid 
     * @param newUserGuid 
     */
    userAdminMergeUsers(params: { "oldUserGuid": string; "newUserGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminMergeUsers(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NhAddressModel> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminPaymentsGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: { "model": UserModelExtended; "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserAdminApiFetchParamCreator.userAdminPutById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserAdminApi - object-oriented interface
 */
export class UserAdminApi extends BaseAPI {
    /** 
     * @param userGuid 
     */
    userAdminAddressGet(params: {  "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminAddressGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param addressGuid 
     */
    userAdminAddressGetById(params: {  "addressGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminAddressGetById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param addressGuid 
     * @param addressModel 
     */
    userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; }, options?: any) {
        return UserAdminApiFp.userAdminAddressPutById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param giveLetters 
     */
    userAdminAdminGetWordGame(params: {  "userGuid": string; "giveLetters"?: string; }, options?: any) {
        return UserAdminApiFp.userAdminAdminGetWordGame(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    userAdminAdminRevokeWordGame(params: {  "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminAdminRevokeWordGame(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param creditGuid 
     */
    userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    userAdminCreditGet(params: {  "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminCreditGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param newCredit 
     */
    userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; }, options?: any) {
        return UserAdminApiFp.userAdminCreditPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     * @param creditGuid 
     * @param credit 
     */
    userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; }, options?: any) {
        return UserAdminApiFp.userAdminCreditPut(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param skip 
     * @param take 
     * @param search 
     */
    userAdminGet(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
        return UserAdminApiFp.userAdminGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    userAdminGetById(params: {  "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetById(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sku 
     */
    userAdminGetUsersbySku(params: {  "sku": string; }, options?: any) {
        return UserAdminApiFp.userAdminGetUsersbySku(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any) {
        return UserAdminApiFp.userAdminHandleAdminUserTicket(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any) {
        return UserAdminApiFp.userAdminHttpPostAdminUserPush(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     */
    userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any) {
        return UserAdminApiFp.userAdminHttpPutAdminUserPush(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param oldUserGuid 
     * @param newUserGuid 
     */
    userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminMergeUsers(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    userAdminPaymentsGet(params: {  "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminPaymentsGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param model 
     * @param userGuid 
     */
    userAdminPutById(params: {  "model": UserModelExtended; "userGuid": string; }, options?: any) {
        return UserAdminApiFp.userAdminPutById(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserAdminApi - factory interface
 */
export const UserAdminApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userGuid 
         */
        userAdminAddressGet(params: {  "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminAddressGet(params, options)(fetch, basePath);
        },
        /** 
         * @param addressGuid 
         */
        userAdminAddressGetById(params: {  "addressGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminAddressGetById(params, options)(fetch, basePath);
        },
        /** 
         * @param addressGuid 
         * @param addressModel 
         */
        userAdminAddressPutById(params: {  "addressGuid": string; "addressModel": NhAddressModel; }, options?: any) {
            return UserAdminApiFp.userAdminAddressPutById(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param giveLetters 
         */
        userAdminAdminGetWordGame(params: {  "userGuid": string; "giveLetters"?: string; }, options?: any) {
            return UserAdminApiFp.userAdminAdminGetWordGame(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        userAdminAdminRevokeWordGame(params: {  "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminAdminRevokeWordGame(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param creditGuid 
         */
        userAdminCreditDelete(params: {  "userGuid": string; "creditGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditDelete(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        userAdminCreditGet(params: {  "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminCreditGet(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param newCredit 
         */
        userAdminCreditPost(params: {  "userGuid": string; "newCredit": NhCreditModel; }, options?: any) {
            return UserAdminApiFp.userAdminCreditPost(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         * @param creditGuid 
         * @param credit 
         */
        userAdminCreditPut(params: {  "userGuid": string; "creditGuid": string; "credit": NhCreditModel; }, options?: any) {
            return UserAdminApiFp.userAdminCreditPut(params, options)(fetch, basePath);
        },
        /** 
         * @param skip 
         * @param take 
         * @param search 
         */
        userAdminGet(params: {  "skip"?: number; "take"?: number; "search"?: string; }, options?: any) {
            return UserAdminApiFp.userAdminGet(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        userAdminGetById(params: {  "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetById(params, options)(fetch, basePath);
        },
        /** 
         * @param sku 
         */
        userAdminGetUsersbySku(params: {  "sku": string; }, options?: any) {
            return UserAdminApiFp.userAdminGetUsersbySku(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userAdminHandleAdminUserTicket(params: {  "model": SupportTicket; }, options?: any) {
            return UserAdminApiFp.userAdminHandleAdminUserTicket(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userAdminHttpPostAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any) {
            return UserAdminApiFp.userAdminHttpPostAdminUserPush(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         */
        userAdminHttpPutAdminUserPush(params: {  "model": AdminUserPushModel; }, options?: any) {
            return UserAdminApiFp.userAdminHttpPutAdminUserPush(params, options)(fetch, basePath);
        },
        /** 
         * @param oldUserGuid 
         * @param newUserGuid 
         */
        userAdminMergeUsers(params: {  "oldUserGuid": string; "newUserGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminMergeUsers(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        userAdminPaymentsGet(params: {  "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminPaymentsGet(params, options)(fetch, basePath);
        },
        /** 
         * @param model 
         * @param userGuid 
         */
        userAdminPutById(params: {  "model": UserModelExtended; "userGuid": string; }, options?: any) {
            return UserAdminApiFp.userAdminPutById(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserCreditApi - fetch parameter creator
 */
export const UserCreditApiFetchParamCreator = {
    /** 
     * @param userGuid 
     */
    userCreditGet(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userCreditGet");
        }
        const baseUrl = `/api/user/{userGuid}/credit`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param userGuid 
     */
    userCreditGetTransactions(params: {  "userGuid": string; }, options?: any): FetchArgs {
        // verify required parameter "userGuid" is set
        if (params["userGuid"] == null) {
            throw new Error("Missing required parameter userGuid when calling userCreditGetTransactions");
        }
        const baseUrl = `/api/admin/user/byGuid/{userGuid}/transactions/list`
            .replace(`{${"userGuid"}}`, `${ params["userGuid"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserCreditApi - functional programming interface
 */
export const UserCreditApiFp = {
    /** 
     * @param userGuid 
     */
    userCreditGet(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserCreditApiFetchParamCreator.userCreditGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param userGuid 
     */
    userCreditGetTransactions(params: { "userGuid": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserCreditApiFetchParamCreator.userCreditGetTransactions(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserCreditApi - object-oriented interface
 */
export class UserCreditApi extends BaseAPI {
    /** 
     * @param userGuid 
     */
    userCreditGet(params: {  "userGuid": string; }, options?: any) {
        return UserCreditApiFp.userCreditGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param userGuid 
     */
    userCreditGetTransactions(params: {  "userGuid": string; }, options?: any) {
        return UserCreditApiFp.userCreditGetTransactions(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserCreditApi - factory interface
 */
export const UserCreditApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param userGuid 
         */
        userCreditGet(params: {  "userGuid": string; }, options?: any) {
            return UserCreditApiFp.userCreditGet(params, options)(fetch, basePath);
        },
        /** 
         * @param userGuid 
         */
        userCreditGetTransactions(params: {  "userGuid": string; }, options?: any) {
            return UserCreditApiFp.userCreditGetTransactions(params, options)(fetch, basePath);
        },
    };
};


/**
 * V2GroupApi - fetch parameter creator
 */
export const V2GroupApiFetchParamCreator = {
    /** 
     * @param content 
     */
    v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupDelete");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     */
    v2GroupGet(options?: any): FetchArgs {
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param id 
     */
    v2GroupGet_1(params: {  "id": string; }, options?: any): FetchArgs {
        // verify required parameter "id" is set
        if (params["id"] == null) {
            throw new Error("Missing required parameter id when calling v2GroupGet_1");
        }
        const baseUrl = `/api/v2/admin/grouping/{id}`
            .replace(`{${"id"}}`, `${ params["id"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     */
    v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupPost");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param content 
     */
    v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any): FetchArgs {
        // verify required parameter "content" is set
        if (params["content"] == null) {
            throw new Error("Missing required parameter content when calling v2GroupPut");
        }
        const baseUrl = `/api/v2/admin/grouping`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["content"]) {
            fetchOptions.body = JSON.stringify(params["content"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * V2GroupApi - functional programming interface
 */
export const V2GroupApiFp = {
    /** 
     * @param content 
     */
    v2GroupDelete(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupDelete(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     */
    v2GroupGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupGet(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param id 
     */
    v2GroupGet_1(params: { "id": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<GroupItemEntity> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupGet_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     */
    v2GroupPost(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param content 
     */
    v2GroupPut(params: { "content": Array<GroupItemEntity>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GroupItemEntity>> {
        const fetchArgs = V2GroupApiFetchParamCreator.v2GroupPut(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * V2GroupApi - object-oriented interface
 */
export class V2GroupApi extends BaseAPI {
    /** 
     * @param content 
     */
    v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupDelete(params, options)(this.fetch, this.basePath);
    }
    /** 
     */
    v2GroupGet(options?: any) {
        return V2GroupApiFp.v2GroupGet(options)(this.fetch, this.basePath);
    }
    /** 
     * @param id 
     */
    v2GroupGet_1(params: {  "id": string; }, options?: any) {
        return V2GroupApiFp.v2GroupGet_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     */
    v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupPost(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param content 
     */
    v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
        return V2GroupApiFp.v2GroupPut(params, options)(this.fetch, this.basePath);
    }
};

/**
 * V2GroupApi - factory interface
 */
export const V2GroupApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * @param content 
         */
        v2GroupDelete(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupDelete(params, options)(fetch, basePath);
        },
        /** 
         */
        v2GroupGet(options?: any) {
            return V2GroupApiFp.v2GroupGet(options)(fetch, basePath);
        },
        /** 
         * @param id 
         */
        v2GroupGet_1(params: {  "id": string; }, options?: any) {
            return V2GroupApiFp.v2GroupGet_1(params, options)(fetch, basePath);
        },
        /** 
         * @param content 
         */
        v2GroupPost(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupPost(params, options)(fetch, basePath);
        },
        /** 
         * @param content 
         */
        v2GroupPut(params: {  "content": Array<GroupItemEntity>; }, options?: any) {
            return V2GroupApiFp.v2GroupPut(params, options)(fetch, basePath);
        },
    };
};


/**
 * WineGeniusApi - fetch parameter creator
 */
export const WineGeniusApiFetchParamCreator = {
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusDeleteSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusDeleteSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusGetSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusGetSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusGetSessionWineGeniusData");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/data`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandleGetVacation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/vacation`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "vacation.dateSet": params["vacationDateSet"],
            "vacation.suspendOn": params["vacationSuspendOn"],
            "vacation.resumeOn": params["vacationResumeOn"],
            "vacation.vacationGuid": params["vacationVacationGuid"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusHandlePostVacation");
        }
        // verify required parameter "vacation" is set
        if (params["vacation"] == null) {
            throw new Error("Missing required parameter vacation when calling wineGeniusHandlePostVacation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/vacation`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["vacation"]) {
            fetchOptions.body = JSON.stringify(params["vacation"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusListSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/list`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusPutSessionOfferReservation");
        }
        // verify required parameter "offerSef" is set
        if (params["offerSef"] == null) {
            throw new Error("Missing required parameter offerSef when calling wineGeniusPutSessionOfferReservation");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/picks/forOffer/{offerSef}`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`)
            .replace(`{${"offerSef"}}`, `${ params["offerSef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusSetSessionWineGeniusData");
        }
        // verify required parameter "data" is set
        if (params["data"] == null) {
            throw new Error("Missing required parameter data when calling wineGeniusSetSessionWineGeniusData");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/data`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["data"]) {
            fetchOptions.body = JSON.stringify(params["data"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusWineGeniusGet(params: {  "sessionId": string; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusWineGeniusGet");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/survey`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusQuestionaire; }, options?: any): FetchArgs {
        // verify required parameter "sessionId" is set
        if (params["sessionId"] == null) {
            throw new Error("Missing required parameter sessionId when calling wineGeniusWineGeniusPost");
        }
        // verify required parameter "postData" is set
        if (params["postData"] == null) {
            throw new Error("Missing required parameter postData when calling wineGeniusWineGeniusPost");
        }
        const baseUrl = `/api/session/{sessionId}/winegenius/survey`
            .replace(`{${"sessionId"}}`, `${ params["sessionId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["postData"]) {
            fetchOptions.body = JSON.stringify(params["postData"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * WineGeniusApi - functional programming interface
 */
export const WineGeniusApiFp = {
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderGeniusState>> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusDeleteSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderGeniusState>> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusGetSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineGeniusData> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusGetSessionWineGeniusData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: { "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WineGeniusVacation>> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandleGetVacation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: { "sessionId": string; "vacation": WineGeniusVacation;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineGeniusVacation> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusHandlePostVacation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderGeniusState>> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusListSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: { "sessionId": string; "offerSef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrderGeniusState>> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusPutSessionOfferReservation(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: { "sessionId": string; "data": WineGeniusData;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineGeniusData> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusSetSessionWineGeniusData(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     */
    wineGeniusWineGeniusGet(params: { "sessionId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineGeniusQuestionaire> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusWineGeniusGet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: { "sessionId": string; "postData": WineGeniusQuestionaire;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineGeniusQuestionaire> {
        const fetchArgs = WineGeniusApiFetchParamCreator.wineGeniusWineGeniusPost(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * WineGeniusApi - object-oriented interface
 */
export class WineGeniusApi extends BaseAPI {
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusDeleteSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusGetSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusGetSessionWineGeniusData(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param vacationDateSet 
     * @param vacationSuspendOn 
     * @param vacationResumeOn 
     * @param vacationVacationGuid 
     */
    wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandleGetVacation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param vacation 
     */
    wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any) {
        return WineGeniusApiFp.wineGeniusHandlePostVacation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusListSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Reveals the allocated items for an order, and finalizes the order.
     * @param sessionId 
     * @param offerSef 
     */
    wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusPutSessionOfferReservation(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param data 
     */
    wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any) {
        return WineGeniusApiFp.wineGeniusSetSessionWineGeniusData(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     */
    wineGeniusWineGeniusGet(params: {  "sessionId": string; }, options?: any) {
        return WineGeniusApiFp.wineGeniusWineGeniusGet(params, options)(this.fetch, this.basePath);
    }
    /** 
     * @param sessionId 
     * @param postData 
     */
    wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusQuestionaire; }, options?: any) {
        return WineGeniusApiFp.wineGeniusWineGeniusPost(params, options)(this.fetch, this.basePath);
    }
};

/**
 * WineGeniusApi - factory interface
 */
export const WineGeniusApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Reveals the allocated items for an order, and finalizes the order.
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusDeleteSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusDeleteSessionOfferReservation(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusGetSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusGetSessionOfferReservation(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        wineGeniusGetSessionWineGeniusData(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusGetSessionWineGeniusData(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param vacationDateSet 
         * @param vacationSuspendOn 
         * @param vacationResumeOn 
         * @param vacationVacationGuid 
         */
        wineGeniusHandleGetVacation(params: {  "sessionId": string; "vacationDateSet"?: Date; "vacationSuspendOn"?: Date; "vacationResumeOn"?: Date; "vacationVacationGuid"?: string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandleGetVacation(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param vacation 
         */
        wineGeniusHandlePostVacation(params: {  "sessionId": string; "vacation": WineGeniusVacation; }, options?: any) {
            return WineGeniusApiFp.wineGeniusHandlePostVacation(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        wineGeniusListSessionOfferReservation(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusListSessionOfferReservation(params, options)(fetch, basePath);
        },
        /** 
         * Reveals the allocated items for an order, and finalizes the order.
         * @param sessionId 
         * @param offerSef 
         */
        wineGeniusPutSessionOfferReservation(params: {  "sessionId": string; "offerSef": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusPutSessionOfferReservation(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param data 
         */
        wineGeniusSetSessionWineGeniusData(params: {  "sessionId": string; "data": WineGeniusData; }, options?: any) {
            return WineGeniusApiFp.wineGeniusSetSessionWineGeniusData(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         */
        wineGeniusWineGeniusGet(params: {  "sessionId": string; }, options?: any) {
            return WineGeniusApiFp.wineGeniusWineGeniusGet(params, options)(fetch, basePath);
        },
        /** 
         * @param sessionId 
         * @param postData 
         */
        wineGeniusWineGeniusPost(params: {  "sessionId": string; "postData": WineGeniusQuestionaire; }, options?: any) {
            return WineGeniusApiFp.wineGeniusWineGeniusPost(params, options)(fetch, basePath);
        },
    };
};


/**
 * WineryApi - fetch parameter creator
 */
export const WineryApiFetchParamCreator = {
    /** 
     * Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandleGetWinery");
        }
        const baseUrl = `/api/v2/winery/{winerySef}`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/api/v2/winery`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "skip": params["skip"],
            "take": params["take"],
            "filter": params["filter"],
            "search": params["search"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandleListWinery_1");
        }
        const baseUrl = `/api/v2/winery/{winerySef}/items`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any): FetchArgs {
        // verify required parameter "winery" is set
        if (params["winery"] == null) {
            throw new Error("Missing required parameter winery when calling wineryHandlePostWinery");
        }
        const baseUrl = `/api/v2/winery`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["winery"]) {
            fetchOptions.body = JSON.stringify(params["winery"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any): FetchArgs {
        // verify required parameter "winerySef" is set
        if (params["winerySef"] == null) {
            throw new Error("Missing required parameter winerySef when calling wineryHandlePutWinery");
        }
        // verify required parameter "winery" is set
        if (params["winery"] == null) {
            throw new Error("Missing required parameter winery when calling wineryHandlePutWinery");
        }
        const baseUrl = `/api/v2/winery/{winerySef}`
            .replace(`{${"winerySef"}}`, `${ params["winerySef"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["winery"]) {
            fetchOptions.body = JSON.stringify(params["winery"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * WineryApi - functional programming interface
 */
export const WineryApiFp = {
    /** 
     * Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: { "winerySef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WineryModel> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleGetWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: { "skip"?: number; "take"?: number; "filter"?: string; "search"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WineryModel>> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleListWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: { "winerySef": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ItemDetailEntity>> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandleListWinery_1(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: { "winery": WineryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandlePostWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: { "winerySef": string; "winery": WineryModel;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = WineryApiFetchParamCreator.wineryHandlePutWinery(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * WineryApi - object-oriented interface
 */
export class WineryApi extends BaseAPI {
    /** 
     * Gets a winery by its id.
     * @param winerySef 
     */
    wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any) {
        return WineryApiFp.wineryHandleGetWinery(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the list of wineries.
     * @param skip 
     * @param take 
     * @param filter 
     * @param search 
     */
    wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any) {
        return WineryApiFp.wineryHandleListWinery(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Gets the list of wines made by a winery.
     * @param winerySef 
     */
    wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any) {
        return WineryApiFp.wineryHandleListWinery_1(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Creates a new winery.
     * @param winery 
     */
    wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any) {
        return WineryApiFp.wineryHandlePostWinery(params, options)(this.fetch, this.basePath);
    }
    /** 
     * Updates an existing winery.
     * @param winerySef 
     * @param winery 
     */
    wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any) {
        return WineryApiFp.wineryHandlePutWinery(params, options)(this.fetch, this.basePath);
    }
};

/**
 * WineryApi - factory interface
 */
export const WineryApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Gets a winery by its id.
         * @param winerySef 
         */
        wineryHandleGetWinery(params: {  "winerySef": string; }, options?: any) {
            return WineryApiFp.wineryHandleGetWinery(params, options)(fetch, basePath);
        },
        /** 
         * Gets the list of wineries.
         * @param skip 
         * @param take 
         * @param filter 
         * @param search 
         */
        wineryHandleListWinery(params: {  "skip"?: number; "take"?: number; "filter"?: string; "search"?: string; }, options?: any) {
            return WineryApiFp.wineryHandleListWinery(params, options)(fetch, basePath);
        },
        /** 
         * Gets the list of wines made by a winery.
         * @param winerySef 
         */
        wineryHandleListWinery_1(params: {  "winerySef": string; }, options?: any) {
            return WineryApiFp.wineryHandleListWinery_1(params, options)(fetch, basePath);
        },
        /** 
         * Creates a new winery.
         * @param winery 
         */
        wineryHandlePostWinery(params: {  "winery": WineryModel; }, options?: any) {
            return WineryApiFp.wineryHandlePostWinery(params, options)(fetch, basePath);
        },
        /** 
         * Updates an existing winery.
         * @param winerySef 
         * @param winery 
         */
        wineryHandlePutWinery(params: {  "winerySef": string; "winery": WineryModel; }, options?: any) {
            return WineryApiFp.wineryHandlePutWinery(params, options)(fetch, basePath);
        },
    };
};

